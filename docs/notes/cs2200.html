<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>./notes/cs2200.md - Notes</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././src/notes/custom.css">
        <link rel="stylesheet" href=".././src/notes/katex.min.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../notes/algorithms.html"><strong aria-hidden="true">1.</strong> ./notes/algorithms.md</a></li><li class="chapter-item "><a href="../notes/arp.html"><strong aria-hidden="true">2.</strong> ./notes/arp.md</a></li><li class="chapter-item "><a href="../notes/asm.html"><strong aria-hidden="true">3.</strong> ./notes/asm.md</a></li><li class="chapter-item "><a href="../notes/basic_preproc.html"><strong aria-hidden="true">4.</strong> ./notes/basic_preproc.md</a></li><li class="chapter-item "><a href="../notes/boost_asio.html"><strong aria-hidden="true">5.</strong> ./notes/boost_asio.md</a></li><li class="chapter-item "><a href="../notes/c_codes.html"><strong aria-hidden="true">6.</strong> ./notes/c_codes.md</a></li><li class="chapter-item "><a href="../notes/classes.html"><strong aria-hidden="true">7.</strong> ./notes/classes.md</a></li><li class="chapter-item "><a href="../notes/cmake.html"><strong aria-hidden="true">8.</strong> ./notes/cmake.md</a></li><li class="chapter-item "><a href="../notes/C_notes.html"><strong aria-hidden="true">9.</strong> ./notes/C_notes.md</a></li><li class="chapter-item "><a href="../notes/compilers.html"><strong aria-hidden="true">10.</strong> ./notes/compilers.md</a></li><li class="chapter-item "><a href="../notes/concurrency.html"><strong aria-hidden="true">11.</strong> ./notes/concurrency.md</a></li><li class="chapter-item "><a href="../notes/cont_struct.html"><strong aria-hidden="true">12.</strong> ./notes/cont_struct.md</a></li><li class="chapter-item "><a href="../notes/cp_codes.html"><strong aria-hidden="true">13.</strong> ./notes/cp_codes.md</a></li><li class="chapter-item "><a href="../notes/cpp_guidelines.html"><strong aria-hidden="true">14.</strong> ./notes/cpp_guidelines.md</a></li><li class="chapter-item "><a href="../notes/cpp.html"><strong aria-hidden="true">15.</strong> ./notes/cpp.md</a></li><li class="chapter-item "><a href="../notes/cp_qs_models.html"><strong aria-hidden="true">16.</strong> ./notes/cp_qs_models.md</a></li><li class="chapter-item "><a href="../notes/cp_qs_reading.html"><strong aria-hidden="true">17.</strong> ./notes/cp_qs_reading.md</a></li><li class="chapter-item expanded "><a href="../notes/cs2200.html" class="active"><strong aria-hidden="true">18.</strong> ./notes/cs2200.md</a></li><li class="chapter-item "><a href="../notes/cs2600.html"><strong aria-hidden="true">19.</strong> ./notes/cs2600.md</a></li><li class="chapter-item "><a href="../notes/csd.html"><strong aria-hidden="true">20.</strong> ./notes/csd.md</a></li><li class="chapter-item "><a href="../notes/cv_qualifiers.html"><strong aria-hidden="true">21.</strong> ./notes/cv_qualifiers.md</a></li><li class="chapter-item "><a href="../notes/data_structures.html"><strong aria-hidden="true">22.</strong> ./notes/data_structures.md</a></li><li class="chapter-item "><a href="../notes/data_types.html"><strong aria-hidden="true">23.</strong> ./notes/data_types.md</a></li><li class="chapter-item "><a href="../notes/dhcp.html"><strong aria-hidden="true">24.</strong> ./notes/dhcp.md</a></li><li class="chapter-item "><a href="../notes/dhcpv6.html"><strong aria-hidden="true">25.</strong> ./notes/dhcpv6.md</a></li><li class="chapter-item "><a href="../notes/dns.html"><strong aria-hidden="true">26.</strong> ./notes/dns.md</a></li><li class="chapter-item "><a href="../notes/enum_classes.html"><strong aria-hidden="true">27.</strong> ./notes/enum_classes.md</a></li><li class="chapter-item "><a href="../notes/file_descriptors.html"><strong aria-hidden="true">28.</strong> ./notes/file_descriptors.md</a></li><li class="chapter-item "><a href="../notes/functions.html"><strong aria-hidden="true">29.</strong> ./notes/functions.md</a></li><li class="chapter-item "><a href="../notes/gdb.html"><strong aria-hidden="true">30.</strong> ./notes/gdb.md</a></li><li class="chapter-item "><a href="../notes/got_plt.html"><strong aria-hidden="true">31.</strong> ./notes/got_plt.md</a></li><li class="chapter-item "><a href="../notes/hacking_basics.html"><strong aria-hidden="true">32.</strong> ./notes/hacking_basics.md</a></li><li class="chapter-item "><a href="../notes/icmp.html"><strong aria-hidden="true">33.</strong> ./notes/icmp.md</a></li><li class="chapter-item "><a href="../notes/if_else_loops.html"><strong aria-hidden="true">34.</strong> ./notes/if_else_loops.md</a></li><li class="chapter-item "><a href="../notes/io.html"><strong aria-hidden="true">35.</strong> ./notes/io.md</a></li><li class="chapter-item "><a href="../notes/ipv4.html"><strong aria-hidden="true">36.</strong> ./notes/ipv4.md</a></li><li class="chapter-item "><a href="../notes/ipv6.html"><strong aria-hidden="true">37.</strong> ./notes/ipv6.md</a></li><li class="chapter-item "><a href="../notes/jpeg.html"><strong aria-hidden="true">38.</strong> ./notes/jpeg.md</a></li><li class="chapter-item "><a href="../notes/memory.html"><strong aria-hidden="true">39.</strong> ./notes/memory.md</a></li><li class="chapter-item "><a href="../notes/narnia_levels.html"><strong aria-hidden="true">40.</strong> ./notes/narnia_levels.md</a></li><li class="chapter-item "><a href="../notes/natas_levels.html"><strong aria-hidden="true">41.</strong> ./notes/natas_levels.md</a></li><li class="chapter-item "><a href="../notes/network_stack.html"><strong aria-hidden="true">42.</strong> ./notes/network_stack.md</a></li><li class="chapter-item "><a href="../notes/poe.html"><strong aria-hidden="true">43.</strong> ./notes/poe.md</a></li><li class="chapter-item "><a href="../notes/pointers.html"><strong aria-hidden="true">44.</strong> ./notes/pointers.md</a></li><li class="chapter-item "><a href="../notes/project_euler.html"><strong aria-hidden="true">45.</strong> ./notes/project_euler.md</a></li><li class="chapter-item "><a href="../notes/python.html"><strong aria-hidden="true">46.</strong> ./notes/python.md</a></li><li class="chapter-item "><a href="../notes/references.html"><strong aria-hidden="true">47.</strong> ./notes/references.md</a></li><li class="chapter-item "><a href="../notes/regex.html"><strong aria-hidden="true">48.</strong> ./notes/regex.md</a></li><li class="chapter-item "><a href="../notes/registers.html"><strong aria-hidden="true">49.</strong> ./notes/registers.md</a></li><li class="chapter-item "><a href="../notes/rust_notes.html"><strong aria-hidden="true">50.</strong> ./notes/rust_notes.md</a></li><li class="chapter-item "><a href="../notes/rvalue_refs.html"><strong aria-hidden="true">51.</strong> ./notes/rvalue_refs.md</a></li><li class="chapter-item "><a href="../notes/static_variables_and_functions.html"><strong aria-hidden="true">52.</strong> ./notes/static_variables_and_functions.md</a></li><li class="chapter-item "><a href="../notes/std_forward.html"><strong aria-hidden="true">53.</strong> ./notes/std_forward.md</a></li><li class="chapter-item "><a href="../notes/strings_arrays.html"><strong aria-hidden="true">54.</strong> ./notes/strings_arrays.md</a></li><li class="chapter-item "><a href="../notes/tcp.html"><strong aria-hidden="true">55.</strong> ./notes/tcp.md</a></li><li class="chapter-item "><a href="../notes/templates.html"><strong aria-hidden="true">56.</strong> ./notes/templates.md</a></li><li class="chapter-item "><a href="../notes/traceroute.html"><strong aria-hidden="true">57.</strong> ./notes/traceroute.md</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cs2200"><a class="header" href="#cs2200">cs2200</a></h1>
<p>Types of grammar:</p>
<ol>
<li>Right linear</li>
<li>Context free</li>
<li>unrestricted</li>
</ol>
<p>Types of machine models:</p>
<ol>
<li>finite memory: finite automata, regex</li>
<li>finite memory with stack: pushdown automata</li>
<li>unrestricted: turing machines, post systems, λ calculus etc.</li>
</ol>
<p>There is a one to one correspondence for the numberings above.</p>
<blockquote>
<p>Gödel’s incompleteness theorem: No matter how strong a deductive system is,
there are always statements that are true but unprovable.</p>
</blockquote>
<h2 id="strings-and-sets"><a class="header" href="#strings-and-sets">Strings and Sets</a></h2>
<blockquote>
<p><em>Decision problem</em> is a function that has a one bit output: true or false,
1 or 0.</p>
</blockquote>
<p>To completely specify a decision problem, specify a set of possible inputs, and
the subset for which the output is true.</p>
<p>Encoding the input of a decision problem as a fixed finite length string is
possible over some fixed finite alphabet.</p>
<blockquote>
<p>A <strong>finite alphabet</strong> is any finite set. A finite length string is a
sequence of the elements.</p>
</blockquote>
<p>Set ops for two sets:</p>
<ul>
<li>Union</li>
<li>Intersection</li>
<li>Complement over set of all strings: Basically, it depends on the <strong>set of
all strings</strong> that is chosen and hence this is often written as
<data class="katex-src" value="\Sigma^* — A"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mtext>—</mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">\Sigma^* — A</annotation></semantics></math></span></data> to emphasize this.</li>
<li>Concatenation of two sets: <data class="katex-src" value="AB = \{xy | x \in A; y \in B\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo>∈</mo><mi>A</mi><mo separator="true">;</mo><mi>y</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">AB = {xy | x \in A; y \in B}</annotation></semantics></math></span></data>.</li>
</ul>
<p>Set ops on one set:</p>
<ul>
<li><em>asterate</em> A<sup>*</sup> of a set. <data class="katex-src" value="A^* = \bigcup_{n\geq 0}A^n"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><msub><mo>⋃</mo><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow></msub><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">A^* = \bigcup_{n\geq 0}A^n</annotation></semantics></math></span></data></li>
<li>A<sup>+</sup> of a set. <data class="katex-src" value="A^+ = \bigcup_{n \geq 1}A^n"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>+</mo></msup><mo>=</mo><msub><mo>⋃</mo><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow></msub><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">A^+ = \bigcup_{n \geq 1}A^n</annotation></semantics></math></span></data>.</li>
</ul>
<h2 id="states-and-transitions"><a class="header" href="#states-and-transitions">States and transitions</a></h2>
<p>A <strong>state</strong> of a system gives all the relevant information of a system, like a
<em>snapshot</em>. <strong>Transitions</strong> are changes of states.</p>
<p>If both are finite, then the system is called a
<em>finite state transition</em> system. We model them using <em>finite automata</em>.</p>
<h3 id="deterministic-finite-automata"><a class="header" href="#deterministic-finite-automata">Deterministic Finite Automata</a></h3>
<p>Formally,</p>
<p><data class="katex-src" value="M = \left(Q,\Sigma,\delta,s,F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M = \left(Q,\Sigma,\delta,s,F\right)</annotation></semantics></math></span></data></p>
<ul>
<li><em>Q</em> is the finite set of states.</li>
<li><data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data> is the finite set of the input <em>alphabet</em>.</li>
<li><data class="katex-src" value="\delta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span></data> is the transition function that takes the current state and the
input <em>character</em> as the inputs and gives the next state as the output.</li>
<li><em>s</em> is the start state.</li>
<li><em>F</em> is the finite subset of <em>Q</em> that are acceptable as the final states.</li>
</ul>
<p>To extend the character input to a <em>string</em>, we define <data class="katex-src" value="\hat{\delta}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\delta}</annotation></semantics></math></span></data>
inductively as follows:</p>
<ul>
<li><data class="katex-src" value="\hat{\delta}\left(q, xa\right) = \delta\left(\hat{\delta}\left(q, x\right),&#10;  a\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>x</mi><mi>a</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>δ</mi><mrow><mo fence="true">(</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(q, xa\right) = \delta\left(\hat{\delta}\left(q, x\right),   a\right)</annotation></semantics></math></span></data></li>
<li><data class="katex-src" value="\hat{\delta}\left(q, \epsilon\right) = q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>ϵ</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(q, \epsilon\right) = q</annotation></semantics></math></span></data></li>
</ul>
<p>Where <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> is a <em>string</em>, <data class="katex-src" value="a"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></data> is a character, and <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> is the empty input.</p>
<p>These can also be translated to the finite state machines
<a href="./csd.html#finite-state-machines">discussed here</a>.</p>
<p>A string <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> is accepted by an automation <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> if</p>
<p><data class="katex-src" value="\hat{\delta}\left(s,x\right) \in F"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>s</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>∈</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(s,x\right) \in F</annotation></semantics></math></span></data></p>
<p>A <em>set</em> or a <em>language</em> accepted by <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> is the set of all strings
accepted by some automata <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data>, also called <data class="katex-src" value="L(M)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(M)</annotation></semantics></math></span></data>. Any subset of <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data>
is said to be regular if it is accepted by some automaton <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data>.</p>
<p><strong>Any</strong> <em>finite</em> subset of <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data> is regular (brute-force all strings).</p>
<blockquote>
<p>Proof that union of two regular languages is regular:</p>
</blockquote>
<p>Let DFA 1 be <data class="katex-src" value="\left(Q_1, \Sigma, \delta_1, s_1, F_1\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><msub><mi>Q</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><msub><mi>δ</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>F</mi><mn>1</mn></msub><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(Q_1, \Sigma, \delta_1, s_1, F_1\right)</annotation></semantics></math></span></data> and DFA 2 be
<data class="katex-src" value="\left(Q_2, \Sigma, \delta_2, s_2, F_2\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><msub><mi>Q</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><msub><mi>δ</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>F</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(Q_2, \Sigma, \delta_2, s_2, F_2\right)</annotation></semantics></math></span></data></p>
<p>The final automata has the cartesian product of the two sets of states as the
set of states (Q), and the delta is also from Q1 x Q2 to Q1 x Q2. The set of
final states is <data class="katex-src" value="Q_1\times F_2 \cup Q_2 \times F_1"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>1</mn></msub><mo>×</mo><msub><mi>F</mi><mn>2</mn></msub><mo>∪</mo><msub><mi>Q</mi><mn>2</mn></msub><mo>×</mo><msub><mi>F</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Q_1\times F_2 \cup Q_2 \times F_1</annotation></semantics></math></span></data>. Also,
<data class="katex-src" value="\hat{\delta}\left(\left(s_1, s_2\right), w\right) =&#10;\left(\hat{\delta}\left(s_1, w\right),\hat{\delta}\left(s_2, w\right)\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mrow><mo fence="true">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>w</mi><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>w</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>s</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>w</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(\left(s_1, s_2\right), w\right) = \left(\hat{\delta}\left(s_1, w\right),\hat{\delta}\left(s_2, w\right)\right)</annotation></semantics></math></span></data></p>
<blockquote>
<p>Proof the the complement of a regular language is also regular:</p>
</blockquote>
<p>All accepted final states become non-accepted, while all non-accepted final
states become accepted.</p>
<blockquote>
<p>Proof that the intersection of two regular languages is also regular:</p>
</blockquote>
<p>Using set properties (De Morgan’s Law), or instead follow the proof of
union and replace the final set with <data class="katex-src" value="F_1 \times F_2"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>×</mo><msub><mi>F</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">F_1 \times F_2</annotation></semantics></math></span></data>.</p>
<h3 id="non-deterministic-finite-automata"><a class="header" href="#non-deterministic-finite-automata">Non-deterministic Finite Automata</a></h3>
<p>A finite automata where the next state is not necessarily determined by the
current state, and the input symbol. It is effectively in a
state of <em>guessing</em>.</p>
<p>To show that an automata accepts a set <data class="katex-src" value="B"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span></data>, we argue that there exists a
lucky sequence of guesses that lead from the start state to an accept state
when the end of <data class="katex-src" value="x\in B"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">x\in B</annotation></semantics></math></span></data> is reached, but for any string outside the set,
it is impossible.</p>
<p>Formally,</p>
<p><data class="katex-src" value="M = \left(Q,\Sigma,\Delta,S,F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M = \left(Q,\Sigma,\Delta,S,F\right)</annotation></semantics></math></span></data></p>
<ul>
<li><em>Q</em> is the finite set of states.</li>
<li><data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data> is the finite set of the input <em>alphabet</em>.</li>
<li><data class="katex-src" value="\Delta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span></data> is the transition function that takes the current state and the
input <em>character</em> as the inputs and gives the next state as the output.
In this case, there are <data class="katex-src" value="2^Q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">2^Q</annotation></semantics></math></span></data> possible outputs, instead of the
<data class="katex-src" value="Q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span></data> possible outputs in case of DFA. Each output corresponds to a unique
element in the power set of <data class="katex-src" value="Q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span></data>.</li>
<li><em>S</em> is the subset of acceptable states called the start states.</li>
<li><em>F</em> is the finite subset of <em>Q</em> that are acceptable as the final states.</li>
</ul>
<p>To define the acceptance, we use the following rules:</p>
<p><data class="katex-src" value="\hat{\Delta}\left(A,\epsilon\right) = A"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>ϵ</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\hat{\Delta}\left(A,\epsilon\right) = A</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="\hat{\Delta}\left(A, xa\right) = \bigcup_{q\in \hat{\Delta}\left(A,x\right)} &#10;\Delta\left(q,a\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mi>a</mi><mo fence="true">)</mo></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><mi>q</mi><mo>∈</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow></munder><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\Delta}\left(A, xa\right) = \bigcup_{q\in \hat{\Delta}\left(A,x\right)}  \Delta\left(q,a\right)</annotation></semantics></math></span></data></p>
<p>Instead of the usual one state, we have the input to be a subset of the
possible state for <data class="katex-src" value="\hat{\Delta}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\Delta}</annotation></semantics></math></span></data>.</p>
<p>Acceptance happens when <data class="katex-src" value="x \in \Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x \in \Sigma^*</annotation></semantics></math></span></data> satisfies <data class="katex-src" value="\hat{\Delta}&#10;\left(S,x\right) \cap F \neq \phi"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>S</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>∩</mo><mi>F</mi><mo mathvariant="normal">≠</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\hat{\Delta} \left(S,x\right) \cap F \neq \phi</annotation></semantics></math></span></data></p>
<p>Proof for Deterministic and Non-deterministic Finite Automata being equivalent:</p>
<ul>
<li>First we prove that <data class="katex-src" value="\hat{\Delta}\left(A, xy\right) =&#10;  \hat{\Delta}\left(\hat{\Delta}\left(A, x\right), y\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mi>y</mi><mo fence="true">)</mo></mrow><mo>=</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>y</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\Delta}\left(A, xy\right) =   \hat{\Delta}\left(\hat{\Delta}\left(A, x\right), y\right)</annotation></semantics></math></span></data></li>
</ul>
<p>Induction on |y|:</p>
<p>For |y| = 0, it is trivially true from the above equations.</p>
<p>Assume for |y| ≤ n,</p>
<p><data class="katex-src" value="&#10;\begin{align*}&#10;\hat{\Delta}\left(A, xya\right) &= \bigcup_{q\in \hat{\Delta}\left(A,xy\right)} &#10;\Delta\left(q,a\right) \\&#10;& = \bigcup_{q\in \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),y\right)} &#10;\Delta\left(q,a\right) \\&#10;& = \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),ya\right)&#10;\end{align*}&#10;"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mi>y</mi><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><mi>q</mi><mo>∈</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mi>y</mi><mo fence="true">)</mo></mrow></mrow></munder><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><mi>q</mi><mo>∈</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>y</mi><mo fence="true">)</mo></mrow></mrow></munder><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>y</mi><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{align*} \hat{\Delta}\left(A, xya\right) &amp;= \bigcup_{q\in \hat{\Delta}\left(A,xy\right)}  \Delta\left(q,a\right) \ &amp; = \bigcup_{q\in \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),y\right)}  \Delta\left(q,a\right) \ &amp; = \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),ya\right) \end{align*} </annotation></semantics></math></span></data></p>
<ul>
<li>Second, the function <data class="katex-src" value="\hat{\Delta}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\Delta}</annotation></semantics></math></span></data> commutes with the set union, i.e.,
<data class="katex-src" value="\hat{\Delta}(\bigcup_i A_i,x) = \bigcup_i \hat{\Delta}(A_i, x)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msub><mo>⋃</mo><mi>i</mi></msub><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>⋃</mo><mi>i</mi></msub><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{\Delta}(\bigcup_i A_i,x) = \bigcup_i \hat{\Delta}(A_i, x)</annotation></semantics></math></span></data></li>
</ul>
<p>Induction on |x|:</p>
<p>For |x| = 0, it is trivially true.</p>
<p>Assume for |x| ≤ n.</p>
<p><data class="katex-src" value="&#10;\begin{align*}&#10;\hat{\Delta}\left(\bigcup_i A_i, xa\right) & = &#10;\hat{\Delta}\left(\hat{\Delta}\left(\bigcup_i A_i,x\right),a\right) \\ & = &#10;\hat{\Delta}\left(\bigcup_i\hat{\Delta}\left(A_i, x\right),a\right) \\ & = &#10;\bigcup_i \hat{\Delta}\left(\hat{\Delta}\left(A_i , x\right), a\right) \\ & = &#10;\bigcup_i\hat{\Delta}\left(A_i, xa\right)&#10;\end{align*}&#10;"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><munder><mo>⋃</mo><mi>i</mi></munder><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><munder><mo>⋃</mo><mi>i</mi></munder><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><munder><mo>⋃</mo><mi>i</mi></munder><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mi>i</mi></munder><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mi>i</mi></munder><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{align*} \hat{\Delta}\left(\bigcup_i A_i, xa\right) &amp; =  \hat{\Delta}\left(\hat{\Delta}\left(\bigcup_i A_i,x\right),a\right) \ &amp; =  \hat{\Delta}\left(\bigcup_i\hat{\Delta}\left(A_i, x\right),a\right) \ &amp; =  \bigcup_i \hat{\Delta}\left(\hat{\Delta}\left(A_i , x\right), a\right) \ &amp; =  \bigcup_i\hat{\Delta}\left(A_i, xa\right) \end{align*} </annotation></semantics></math></span></data></p>
<p>Now the following two automata can be shown to accept the same set.</p>
<p><data class="katex-src" value="\left(Q, \Sigma, \Delta, S, F\right) = \left(2^Q, \Sigma, \hat{\Delta}, S, &#10;\{ A | A \subseteq Q, A \cap F ≠ \phi\} \right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><msup><mn>2</mn><mi>Q</mi></msup><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo>⊆</mo><mi>Q</mi><mo separator="true">,</mo><mi>A</mi><mo>∩</mo><mi>F</mi><mo mathvariant="normal">≠</mo><mi>ϕ</mi><mo stretchy="false">}</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(Q, \Sigma, \Delta, S, F\right) = \left(2^Q, \Sigma, \hat{\Delta}, S,  { A | A \subseteq Q, A \cap F ≠ \phi} \right)</annotation></semantics></math></span></data></p>
<p>To create a minimal DFA from an NFA, check the decision tree for the NFA and
do a BFS, stopping when you don’t get any new states.</p>
<h4 id="ϵepsilon-transition"><a class="header" href="#ϵepsilon-transition"><data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> transition</a></h4>
<p>This has an <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> slip that allows the state to transition without
reading any input symbol.</p>
<blockquote>
<p>Proof that <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> transition NFA’s have an equivalent NFA with just one
start state and no <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> transitions.</p>
</blockquote>
<p><strong>Defn:</strong> <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> closure: The set of all states that a state can reach on
an <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> transition.</p>
<p>Define a new transition function such that the states attained by the state
with <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> transitions further take one symbol.</p>
<p>For an <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> NFA to be converted to a regular NFA, we define</p>
<p><data class="katex-src" value="\begin{align*}&#10;\Delta'\left(q,\sigma\right) = \bigcup_{q'\in \epsilon(q)}&#10;\Delta\left(q', \sigma\right)&#10;\end{align*}&#10;"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi mathvariant="normal">Δ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>σ</mi><mo fence="true">)</mo></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi>ϵ</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow></munder><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>σ</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*} \Delta'\left(q,\sigma\right) = \bigcup_{q'\in \epsilon(q)} \Delta\left(q', \sigma\right) \end{align*} </annotation></semantics></math></span></data></p>
<p>where <data class="katex-src" value="\epsilon(q)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\epsilon(q)</annotation></semantics></math></span></data> is the <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> closure of q.</p>
<p>The final states</p>
<p><data class="katex-src" value="&#10;F' = \{q | \epsilon(q)\cap F \neq \phi\}&#10;"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">{</mo><mi>q</mi><mi mathvariant="normal">∣</mi><mi>ϵ</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>F</mi><mo mathvariant="normal">≠</mo><mi>ϕ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex"> F' = {q | \epsilon(q)\cap F \neq \phi} </annotation></semantics></math></span></data></p>
<p>Everything else remains the same.</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<ul>
<li><data class="katex-src" value="a"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></data> for each <data class="katex-src" value="a \in \Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">a \in \Sigma</annotation></semantics></math></span></data>, matched by <data class="katex-src" value="a"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></data> only.</li>
<li><data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data>, matched by the empty string.</li>
<li><data class="katex-src" value="\phi"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span></data>, matched by nothing.</li>
<li>#, matched by any symbol in <data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="@"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">@</mi></mrow><annotation encoding="application/x-tex">@</annotation></semantics></math></span></data>, matched by anything in <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data>.</li>
</ul>
<h3 id="combining-patterns"><a class="header" href="#combining-patterns">Combining patterns</a></h3>
<ul>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha + \beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>+</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha + \beta</annotation></semantics></math></span></data> if <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches either of those.</li>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha\cap\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∩</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha\cap\beta</annotation></semantics></math></span></data> if <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches both of them.</li>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha\beta</annotation></semantics></math></span></data> if <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span></data> followed by <data class="katex-src" value="\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="~\alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>α</mi></mrow><annotation encoding="application/x-tex">~\alpha</annotation></semantics></math></span></data> if it doesn’t match <data class="katex-src" value="\alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\alpha^*</annotation></semantics></math></span></data> and <data class="katex-src" value="\alpha^+"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\alpha^+</annotation></semantics></math></span></data> the same way as regex.</li>
</ul>
<p>NOTE:<br>
<data class="katex-src" value="\left(0 + 1\right)^* "><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo fence="true">(</mo><mn>0</mn><mo>+</mo><mn>1</mn><mo fence="true">)</mo></mrow><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\left(0 + 1\right)^* </annotation></semantics></math></span></data> accepts 010101<br>
<data class="katex-src" value=" 0^* + 1^* "><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>0</mn><mo>∗</mo></msup><mo>+</mo><msup><mn>1</mn><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex"> 0^* + 1^* </annotation></semantics></math></span></data> accepts 000000 or 111111 but only strings of one symbol</p>
<p>For any pattern <data class="katex-src" value="R"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span></data>, we define <data class="katex-src" value="L(R)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(R)</annotation></semantics></math></span></data> to be the language that matches the
pattern <data class="katex-src" value="R"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span></data>.</p>
<p>Any regular language can have countably infinite representations in form of
patterns.</p>
<p><strong>Theorem</strong>: If <data class="katex-src" value="R"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span></data> is a regular expression, then <data class="katex-src" value="L(R)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(R)</annotation></semantics></math></span></data> is regular.</p>
<p>Proof: Check for each possible case and all of them can be decomposed into a
combination of the above situations.</p>
<blockquote>
<p>It is always possible to remove the complement in a regular expression.</p>
</blockquote>
<h3 id="dfas-to-regex"><a class="header" href="#dfas-to-regex">DFAs to Regex</a></h3>
<ul>
<li>State elimination
<ul>
<li>Keep remaining states</li>
<li>Replace transitions with transitions labelled as regex.</li>
<li>while true</li>
</ul>
</li>
</ul>
<h2 id="class"><a class="header" href="#class">Class</a></h2>
<p><strong>Theorem:</strong> Set of all C Programs is countable.</p>
<p>Proof: <br></p>
<p>Represent the ascii source code in binary. Then it will be a subset of
<data class="katex-src" value="\{0,1\}^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">}</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">{0,1}^*</annotation></semantics></math></span></data> and that is bijective with the natural numbers
(<data class="katex-src" value="n(b) + 2^{|b|} -1"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mrow><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n(b) + 2^{|b|} -1</annotation></semantics></math></span></data>). It is also obviously infinite.</p>
<blockquote>
<p>Hilbert’s Entscheidungs Problem: Given a mathematical statement, is
it derivable from the axioms?</p>
</blockquote>
<p><strong>Defn:</strong> A language <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data> over an alphabet <data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data> is a subset of <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data>.</p>
<p><strong>Theorem:</strong> The cardinality of all the languages over some alphabet is
uncountably infinite, i.e., <data class="katex-src" value="\left|\mathcal{P}\left(L\right)\right| >&#10;\left|\mathbb{N}\right|"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><mi mathvariant="script">P</mi><mrow><mo fence="true">(</mo><mi>L</mi><mo fence="true">)</mo></mrow><mo fence="true">∣</mo></mrow><mo>&gt;</mo><mrow><mo fence="true">∣</mo><mi mathvariant="double-struck">N</mi><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">\left|\mathcal{P}\left(L\right)\right| &gt; \left|\mathbb{N}\right|</annotation></semantics></math></span></data>.</p>
<p>Proof:</p>
<p>Cantor’s argument:</p>
<p>Set of all languages = <data class="katex-src" value="\mathcal{P}\left(\{0,1\}^*\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi><mrow><mo fence="true">(</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">}</mo><mo>∗</mo></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{P}\left({0,1}^*\right)</annotation></semantics></math></span></data></p>
<div class="table-wrapper"><table><thead><tr><th>input</th><th><data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data></th><th>0</th><th>1</th><th>00</th></tr></thead><tbody>
<tr><td>f(<data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data>)</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>f(0)</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>f(1)</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>f(01)</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>
</tbody></table>
</div>
<p>The entries in the table tell whether that particular element is present in the
subset is gotten from the result or not.</p>
<p>Take the diagonal and bit flip all bits. It will differ from all the strings in
the table by atleast one bit.</p>
<p>Go to <a href="./cs2200.html#cs2200">top</a> till
<a href="./cs2200.html#deterministic-finite-automata">Deterministic Finite Automata</a>
along with a few examples of languages based on the problem.</p>
<h3 id="limits-of-dfas"><a class="header" href="#limits-of-dfas">Limits of DFAs</a></h3>
<ul>
<li>DFAs have finite memory.</li>
<li>They can also only read one symbol at a time from left to right.</li>
</ul>
<p>For instance, there is no way of constructing a DFA that can accept <data class="katex-src" value="L =&#10;\{0^n1^n | n \in \mathbb{N}\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false">{</mo><msup><mn>0</mn><mi>n</mi></msup><msup><mn>1</mn><mi>n</mi></msup><mi mathvariant="normal">∣</mi><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L = {0^n1^n | n \in \mathbb{N}}</annotation></semantics></math></span></data>.</p>
<p>Similarly, there is no DFA that can accept the language <data class="katex-src" value="L = \{0^{2^n}| n&#10;\in \mathbb{N}\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false">{</mo><msup><mn>0</mn><msup><mn>2</mn><mi>n</mi></msup></msup><mi mathvariant="normal">∣</mi><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L = {0^{2^n}| n \in \mathbb{N}}</annotation></semantics></math></span></data></p>
<blockquote>
<p>Important Proof</p>
</blockquote>
<p>If <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data> is regular, where <data class="katex-src" value="L = \{ww | w \in \Sigma^* \}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false">{</mo><mi>w</mi><mi>w</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L = {ww | w \in \Sigma^* }</annotation></semantics></math></span></data>, then <data class="katex-src" value="\sqrt{L}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>L</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{L}</annotation></semantics></math></span></data> is
also regular.</p>
<p>Proof:</p>
<p>Let the DFA be <data class="katex-src" value="\left(Q, \Sigma, \delta, q_0, F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(Q, \Sigma, \delta, q_0, F\right)</annotation></semantics></math></span></data>. We define the
NFA as follows:</p>
<p><data class="katex-src" value="N = \left(Q \times Q \times Q, \Sigma, \Delta, A, f\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>N</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo>×</mo><mi>Q</mi><mo>×</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo separator="true">,</mo><mi>A</mi><mo separator="true">,</mo><mi>f</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">N = \left(Q \times Q \times Q, \Sigma, \Delta, A, f\right)</annotation></semantics></math></span></data></p>
<p>where</p>
<p><data class="katex-src" value="\begin{align}&#10;A &= \bigcup_{i\in Q} {\left(i, q_0, i\right)}&#10;\\&#10;f &= \bigcup_{i \in Q\atop z\in F} {\left(i, i, z\right)}&#10;\\&#10;\Delta\left(\left(i, \alpha, \beta\right), a_0\right) &= \left(i, &#10;\delta\left(\alpha, a_0\right), \delta\left(\beta, a_0\right)\right)&#10;\end{align}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>A</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><mi>i</mi><mo>∈</mo><mi>Q</mi></mrow></munder><mrow><mo fence="true">(</mo><mi>i</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>i</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>f</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mfrac linethickness="0px"><mrow><mi>i</mi><mo>∈</mo><mi>Q</mi></mrow><mrow><mi>z</mi><mo>∈</mo><mi>F</mi></mrow></mfrac></munder><mrow><mo fence="true">(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>z</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><mrow><mo fence="true">(</mo><mi>i</mi><mo separator="true">,</mo><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mi>i</mi><mo separator="true">,</mo><mi>δ</mi><mrow><mo fence="true">(</mo><mi>α</mi><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>δ</mi><mrow><mo fence="true">(</mo><mi>β</mi><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} A &amp;= \bigcup_{i\in Q} {\left(i, q_0, i\right)} \ f &amp;= \bigcup_{i \in Q\atop z\in F} {\left(i, i, z\right)} \ \Delta\left(\left(i, \alpha, \beta\right), a_0\right) &amp;= \left(i,  \delta\left(\alpha, a_0\right), \delta\left(\beta, a_0\right)\right) \end{align}</annotation></semantics></math></span></data></p>
<h3 id="pumping-lemma"><a class="header" href="#pumping-lemma">Pumping Lemma</a></h3>
<p>Let <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data> be a regular language. <data class="katex-src" value="\exists k > 0"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>k</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\exists k &gt; 0</annotation></semantics></math></span></data>, s.t. <data class="katex-src" value="\forall x,y,z"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">\forall x,y,z</annotation></semantics></math></span></data> s.t.
<data class="katex-src" value="xyz \in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">xyz \in L</annotation></semantics></math></span></data> and <data class="katex-src" value="|y| > k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">|y| &gt; k</annotation></semantics></math></span></data>, <data class="katex-src" value="\exists u,v,w"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">\exists u,v,w</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="y = uvw, v\ne \epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>u</mi><mi>v</mi><mi>w</mi><mo separator="true">,</mo><mi>v</mi><mo mathvariant="normal">≠</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">y = uvw, v\ne \epsilon</annotation></semantics></math></span></data>
s.t. <data class="katex-src" value="\forall i \geq 0, xuv^iwz \in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo>≥</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mi>u</mi><msup><mi>v</mi><mi>i</mi></msup><mi>w</mi><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\forall i \geq 0, xuv^iwz \in L</annotation></semantics></math></span></data>.</p>
<p>Proof: <data class="katex-src" value="\exists M = \left(Q, \Sigma, \delta, q_0, F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\exists M = \left(Q, \Sigma, \delta, q_0, F\right)</annotation></semantics></math></span></data> s.t.
<data class="katex-src" value="L\left(M\right) = L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo fence="true">(</mo><mi>M</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L\left(M\right) = L</annotation></semantics></math></span></data>.</p>
<p>Set <data class="katex-src" value="k = |Q|"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>Q</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">k = |Q|</annotation></semantics></math></span></data></p>
<p>Let <data class="katex-src" value="x,y,z \in \Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x,y,z \in \Sigma^*</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="|y| > k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">|y| &gt; k</annotation></semantics></math></span></data> &amp; <data class="katex-src" value="xyz \in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">xyz \in L</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="\begin{align*}&#10;\hat{\delta}\left(q_0, x\right) &= q &&#10;\hat{\delta}\left(q, y\right) &= q' &&#10;\hat{\delta}\left(q', z\right) & \in F &&#10;\end{align*}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left right left right left right" columnspacing="0em 1em 0em 1em 0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>q</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>y</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>z</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>∈</mo><mi>F</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*} \hat{\delta}\left(q_0, x\right) &amp;= q &amp; \hat{\delta}\left(q, y\right) &amp;= q' &amp; \hat{\delta}\left(q', z\right) &amp; \in F &amp; \end{align*}</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="y = y_1y_2...y_r, r> k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>y</mi><mn>1</mn></msub><msub><mi>y</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>r</mi></msub><mo separator="true">,</mo><mi>r</mi><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">y = y_1y_2…y_r, r&gt; k</annotation></semantics></math></span></data>. We define <data class="katex-src" value="q_i = \hat{\delta}&#10;\left(q, y_1y_2...y_i\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mi>i</mi></msub><mo>=</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><msub><mi>y</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">q_i = \hat{\delta} \left(q, y_1y_2…y_i\right)</annotation></semantics></math></span></data></p>
<p>Consider the sequence <data class="katex-src" value="q_1q_2q_3...q_r"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub><msub><mi>q</mi><mn>2</mn></msub><msub><mi>q</mi><mn>3</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>q</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">q_1q_2q_3…q_r</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="\implies \exists s, t"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi mathvariant="normal">∃</mi><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">\implies \exists s, t</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="q_s = q_t"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mi>s</mi></msub><mo>=</mo><msub><mi>q</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">q_s = q_t</annotation></semantics></math></span></data> in the sequence (by PHP).</p>
<p>Define</p>
<p><data class="katex-src" value="u = y_1y_2...y_s"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>u</mi><mo>=</mo><msub><mi>y</mi><mn>1</mn></msub><msub><mi>y</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">u = y_1y_2…y_s</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="v = y_{s+1}y_{s+2}...y_t"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mo>=</mo><msub><mi>y</mi><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>y</mi><mrow><mi>s</mi><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">v = y_{s+1}y_{s+2}…y_t</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="w = y_{t+1}y_{t+2}...y_r"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo>=</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>y</mi><mrow><mi>t</mi><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">w = y_{t+1}y_{t+2}…y_r</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="\begin{align}&#10;\hat{\delta}\left(q_0, x\right)  &= q &#10;\\&#10;\hat{\delta}\left(q, u\right)  &= q_s &#10;\\&#10;\hat{\delta}\left(q_s, v\right)  &= q_s \implies \hat{\delta}&#10;\left(q_s, v^i\right) = q_s &#10;\\&#10;\hat{\delta}\left(q_s, wz\right)  &\in F&#10;\end{align}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>q</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>u</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>q</mi><mi>s</mi></msub></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mi>s</mi></msub><mo separator="true">,</mo><mi>v</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>q</mi><mi>s</mi></msub><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mi>s</mi></msub><mo separator="true">,</mo><msup><mi>v</mi><mi>i</mi></msup><mo fence="true">)</mo></mrow><mo>=</mo><msub><mi>q</mi><mi>s</mi></msub></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mi>s</mi></msub><mo separator="true">,</mo><mi>w</mi><mi>z</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>∈</mo><mi>F</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} \hat{\delta}\left(q_0, x\right)  &amp;= q  \ \hat{\delta}\left(q, u\right)  &amp;= q_s  \ \hat{\delta}\left(q_s, v\right)  &amp;= q_s \implies \hat{\delta} \left(q_s, v^i\right) = q_s  \ \hat{\delta}\left(q_s, wz\right)  &amp;\in F \end{align}</annotation></semantics></math></span></data></p>
<p>An analogy with a 2 player game:</p>
<p>Prover: I’ll give you a number k</p>
<p>Spoiler: I’ll find x, y, z such that the concatenation is in the language with
length of y &gt; k</p>
<p>Prover: I’ll split y into u, v, w where v is non-empty.</p>
<p>Spoiler: I’ll find an i &gt; 0 such that the pumping lemma string doesn’t belong
in the DFA. If I do that, I’ll win. And L will not be regular.</p>
<h3 id="an-alternate-way-to-prove-that-a-language-is-not-regular"><a class="header" href="#an-alternate-way-to-prove-that-a-language-is-not-regular">An alternate way to prove that a language is not regular.</a></h3>
<p>Suppose you take a DFA for the language. We take an infinite set of strings
such that all of them go to a different state. Then it’s obvious that the
DFA cannot be finite and hence, it is not a DFA.</p>
<p>Example:</p>
<p><data class="katex-src" value="\begin{align}&#10;L &= \{0^n1^n | n \ge 0\}&#10;\\&#10;M &= \left(Q, \Sigma, \delta, q_0, F\right)&#10;\\&#10;L &= L\left(M\right)&#10;\\&#10;W &= \{0^i | i \ge 0\}&#10;\end{align}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>L</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">{</mo><msup><mn>0</mn><mi>n</mi></msup><msup><mn>1</mn><mi>n</mi></msup><mi mathvariant="normal">∣</mi><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">}</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>M</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>L</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>L</mi><mrow><mo fence="true">(</mo><mi>M</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>W</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">{</mo><msup><mn>0</mn><mi>i</mi></msup><mi mathvariant="normal">∣</mi><mi>i</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">}</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} L &amp;= {0^n1^n | n \ge 0} \ M &amp;= \left(Q, \Sigma, \delta, q_0, F\right) \ L &amp;= L\left(M\right) \ W &amp;= {0^i | i \ge 0} \end{align}</annotation></semantics></math></span></data></p>
<p>We claim that any two strings in <data class="katex-src" value="W"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span></data> reach a different state.</p>
<p><strong>Proof:</strong></p>
<p><data class="katex-src" value="\begin{align}&#10;\hat{\delta}\left(q_0, 0^i\right) &\ne \hat{\delta}\left(q_0, 0^j\right) &#10;\forall i \ne j&#10;\\&#10;\hat{\delta}\left(q_0, 0^i1^i\right) &= \hat{\delta}\left(\hat{\delta}&#10;\left(q_0, 0 ^i\right), 1^i\right) &#10;\\&#10;&\ne \hat{\delta}\left(\hat{\delta}\left(q_0, 0^j\right), 1^i\right)&#10;\end{align}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><msup><mn>0</mn><mi>i</mi></msup><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo mathvariant="normal">≠</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><msup><mn>0</mn><mi>j</mi></msup><mo fence="true">)</mo></mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><msup><mn>0</mn><mi>i</mi></msup><msup><mn>1</mn><mi>i</mi></msup><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><msup><mn>0</mn><mi>i</mi></msup><mo fence="true">)</mo></mrow><mo separator="true">,</mo><msup><mn>1</mn><mi>i</mi></msup><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo mathvariant="normal">≠</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><msup><mn>0</mn><mi>j</mi></msup><mo fence="true">)</mo></mrow><mo separator="true">,</mo><msup><mn>1</mn><mi>i</mi></msup><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} \hat{\delta}\left(q_0, 0^i\right) &amp;\ne \hat{\delta}\left(q_0, 0^j\right)  \forall i \ne j \ \hat{\delta}\left(q_0, 0^i1^i\right) &amp;= \hat{\delta}\left(\hat{\delta} \left(q_0, 0 ^i\right), 1^i\right)  \ &amp;\ne \hat{\delta}\left(\hat{\delta}\left(q_0, 0^j\right), 1^i\right) \end{align}</annotation></semantics></math></span></data></p>
<p>If this wasn’t true then both the strings will be accepted, which is
impossible according to the language.</p>
<h3 id="distinguishability"><a class="header" href="#distinguishability">Distinguishability</a></h3>
<p><strong>Defn</strong>: Let <data class="katex-src" value="L \subseteq \Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^<em></annotation></semantics></math></span></data> be a language. Two strings <data class="katex-src" value="x,y \in&#10;\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x,y \in \Sigma^</em></annotation></semantics></math></span></data> are said to be distinguishable by <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data> if <data class="katex-src" value="\exists z \in&#10;\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\exists z \in \Sigma^*</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="xz \in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">xz \in L</annotation></semantics></math></span></data> and <data class="katex-src" value="yz \notin L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mi>z</mi><mo mathvariant="normal">∉</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">yz \notin L</annotation></semantics></math></span></data>.</p>
<p><strong>Defn</strong>: A set <data class="katex-src" value="S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span></data> is distinguishable if <data class="katex-src" value="\forall i \ne j \in S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\forall i \ne j \in S</annotation></semantics></math></span></data> and <data class="katex-src" value="i"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span></data>
and <data class="katex-src" value="j"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span></data> are distinguishable.</p>
<p><strong>Theorem</strong>: Let <data class="katex-src" value="L \subseteq \Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math></span></data> be a regular language and <data class="katex-src" value="S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span></data> be
a distinguishable set. For any DFA accepting <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data>, <data class="katex-src" value="\left|Q\right| \ge&#10;\left|S\right|"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><mi>Q</mi><mo fence="true">∣</mo></mrow><mo>≥</mo><mrow><mo fence="true">∣</mo><mi>S</mi><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">\left|Q\right| \ge \left|S\right|</annotation></semantics></math></span></data>.</p>
<h3 id="myhill-nerode-relations"><a class="header" href="#myhill-nerode-relations">Myhill-Nerode Relations</a></h3>
<p>An equivalence relation <data class="katex-src" value="\equiv"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span></data> over a language <data class="katex-src" value="L \subseteq \Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math></span></data> is
said to be a <em>Myhill-Nerode relation</em> if</p>
<ol>
<li><data class="katex-src" value="\equiv"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span></data> is a right congruence, i.e., if <data class="katex-src" value="x \equiv y"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \equiv y</annotation></semantics></math></span></data>, then <data class="katex-src" value="x\sigma&#10;   \equiv y\sigma \forall \sigma \in \Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>σ</mi><mo>≡</mo><mi>y</mi><mi>σ</mi><mi mathvariant="normal">∀</mi><mi>σ</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">x\sigma    \equiv y\sigma \forall \sigma \in \Sigma</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="\equiv"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span></data> is a refinement of <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data>, i.e., if <data class="katex-src" value="x\equiv y"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\equiv y</annotation></semantics></math></span></data> then <data class="katex-src" value="x\in L&#10;   \iff y\in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>L</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>y</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">x\in L    \iff y\in L</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="\equiv"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span></data> is of finite index.</li>
</ol>
<p>If <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data> is regular and <data class="katex-src" value="M = \left(Q,\Sigma, \delta, q_0, F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M = \left(Q,\Sigma, \delta, q_0, F\right)</annotation></semantics></math></span></data>
accepts M, then <data class="katex-src" value="\equiv_M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>≡</mo><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">\equiv_M</annotation></semantics></math></span></data> is a <em>Myhill-Nerode</em> relation.
It is trivial to see why this is the case.</p>
<p>We define <data class="katex-src" value="\equiv_M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>≡</mo><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">\equiv_M</annotation></semantics></math></span></data> to be the equivalence relation gotten when any two
strings end up in the same equivalence class in the language accepted by
<data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> i.e. <data class="katex-src" value="\hat{\delta}\left(q_0, x\right) = \hat{\delta}\left(q_0, y\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>=</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>y</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(q_0, x\right) = \hat{\delta}\left(q_0, y\right)</annotation></semantics></math></span></data>.</p>
<p>We define <data class="katex-src" value="\equiv_L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>≡</mo><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">\equiv_L</annotation></semantics></math></span></data> to be the equivalence relation gotten when any two
strings <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> and <data class="katex-src" value="y"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="\forall z \in \Sigma^*, xz \in L&#10;\Longleftrightarrow yz \in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo separator="true">,</mo><mi>x</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mo>⟺</mo><mi>y</mi><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\forall z \in \Sigma^*, xz \in L \Longleftrightarrow yz \in L</annotation></semantics></math></span></data>.</p>
<p><strong>Theorem</strong>: Let <data class="katex-src" value="\equiv"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span></data> be an MH relation over <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data>.</p>
<p>Then <data class="katex-src" value="\equiv \subseteq \equiv_L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo><mo>⊆</mo><msub><mo>≡</mo><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">\equiv \subseteq \equiv_L</annotation></semantics></math></span></data>.</p>
<p>Proof:</p>
<p><data class="katex-src" value="\begin{align}&#10;&\forall x,y, x\equiv y &#10;\\&#10;&\forall \sigma \in \Sigma, x\sigma \equiv y\sigma &#10;\\&#10;&\forall z \in \Sigma^* , \implies \left(xz \in L \iff yz\in L\right)&#10;\\&#10;&\implies x\equiv_L y&#10;\end{align}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo>≡</mo><mi>y</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi mathvariant="normal">∀</mi><mi>σ</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>x</mi><mi>σ</mi><mo>≡</mo><mi>y</mi><mi>σ</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi mathvariant="normal">∀</mi><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo separator="true">,</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mrow><mo fence="true">(</mo><mi>x</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>y</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>x</mi><msub><mo>≡</mo><mi>L</mi></msub><mi>y</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} &amp;\forall x,y, x\equiv y  \ &amp;\forall \sigma \in \Sigma, x\sigma \equiv y\sigma  \ &amp;\forall z \in \Sigma^* , \implies \left(xz \in L \iff yz\in L\right) \ &amp;\implies x\equiv_L y \end{align}</annotation></semantics></math></span></data></p>
<h3 id="minimizing-dfas-and-isomorphism"><a class="header" href="#minimizing-dfas-and-isomorphism">Minimizing DFAs and Isomorphism</a></h3>
<p>Let <data class="katex-src" value="M = \left(Q,\Sigma, \delta, s, F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M = \left(Q,\Sigma, \delta, s, F\right)</annotation></semantics></math></span></data> and <data class="katex-src" value="M' = \left(Q', \Sigma,&#10;\delta', s', F' \right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mrow><mo fence="true">(</mo><msup><mi>Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><msup><mi>δ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M' = \left(Q', \Sigma, \delta', s', F' \right)</annotation></semantics></math></span></data></p>
<p>Let <data class="katex-src" value="f: Q\rightarrow Q'"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>Q</mi><mo>→</mo><msup><mi>Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f: Q\rightarrow Q'</annotation></semantics></math></span></data> be a bijection such that the following hold:</p>
<ol>
<li><data class="katex-src" value="s' = f(s)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s' = f(s)</annotation></semantics></math></span></data></li>
<li><data class="katex-src" value="q\in F \Longleftrightarrow f(q) \in F'"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>∈</mo><mi>F</mi><mo>⟺</mo><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>∈</mo><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">q\in F \Longleftrightarrow f(q) \in F'</annotation></semantics></math></span></data></li>
<li><data class="katex-src" value="f(\delta(q,\sigma)) = \delta'(f(q), \sigma) \forall q \in Q, \sigma \in&#10;   \Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>δ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∀</mi><mi>q</mi><mo>∈</mo><mi>Q</mi><mo separator="true">,</mo><mi>σ</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">f(\delta(q,\sigma)) = \delta'(f(q), \sigma) \forall q \in Q, \sigma \in    \Sigma</annotation></semantics></math></span></data></li>
</ol>
<p><strong>Theorem</strong>: If <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> and <data class="katex-src" value="M'"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M'</annotation></semantics></math></span></data> are two minimal automatas then they are isomorphic.</p>
<p>Proof:</p>
<p>We define the function <data class="katex-src" value="f^{-1}: Q' \rightarrow Q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>:</mo><msup><mi>Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">f^{-1}: Q' \rightarrow Q</annotation></semantics></math></span></data> to be <data class="katex-src" value="\hat{\delta}(s, x)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{\delta}(s, x)</annotation></semantics></math></span></data></p>
<p><strong>Algorithm</strong> to minimize the DFA:</p>
<p>States <data class="katex-src" value="q, q' \in M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo separator="true">,</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">q, q' \in M</annotation></semantics></math></span></data> are equivalent if <data class="katex-src" value="\forall x\in \Sigma^*, \hat{\delta}&#10;(q,x) \in F \Longleftrightarrow \hat{\delta}(q', x) \in F"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo separator="true">,</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>F</mi><mo>⟺</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">\forall x\in \Sigma^*, \hat{\delta} (q,x) \in F \Longleftrightarrow \hat{\delta}(q', x) \in F</annotation></semantics></math></span></data></p>
<p>This is clearly an equivalence relation for the states.</p>
<p>Show that the Myhill-Nerode relation of the <strong>Quotient Automata</strong>
<data class="katex-src" value="M_{/\approx}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mrow><mi mathvariant="normal">/</mi><mo>≈</mo></mrow></msub></mrow><annotation encoding="application/x-tex">M_{/\approx}</annotation></semantics></math></span></data> is a superset of the other. Hence the quotient automata is the
minimal one.</p>
<p><em>Algorithm</em>:</p>
<p>Mark any two pairs of states that are clearly not equivalent (one of them is a
final state, other is not).</p>
<p>Repeat until no new pairs are marked</p>
<p>If <data class="katex-src" value="\exists \{p,q\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mo stretchy="false">{</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\exists {p,q}</annotation></semantics></math></span></data> s.t. for some <data class="katex-src" value="\sigma \in \Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\sigma \in \Sigma</annotation></semantics></math></span></data>, <data class="katex-src" value="\{\delta(p,\sigma),&#10;\delta(q,\sigma)\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">{\delta(p,\sigma), \delta(q,\sigma)}</annotation></semantics></math></span></data> are marked then mark <data class="katex-src" value="\{p,q\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">{p,q}</annotation></semantics></math></span></data></p>
<p>Go to <a href="./cs2200.html#pattern-matching">pattern matching</a></p>
<h3 id="context-free-languages"><a class="header" href="#context-free-languages">Context free languages</a></h3>
<p>Productions: A kind of statement that telly you substitution rule.</p>
<p>Non-terminal strings are strings that can be replaced using productions.</p>
<p>Terminals are ones that can’t be further replaced.</p>
<p>Therefore, CFG is a 4 tuple that is defined using
<data class="katex-src" value="\left(N, \Sigma, P, S\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mi>N</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(N, \Sigma, P, S\right)</annotation></semantics></math></span></data></p>
<ul>
<li><data class="katex-src" value="N"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></data> is the set of non-terminals (RHS in any production).</li>
<li><data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data> set of terminals</li>
<li><data class="katex-src" value="P"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span></data> set of production girls</li>
<li><data class="katex-src" value="S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span></data> start symbol</li>
</ul>
<p>E.g. <data class="katex-src" value="L = \{0^n1^n| n \ge 0\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false">{</mo><msup><mn>0</mn><mi>n</mi></msup><msup><mn>1</mn><mi>n</mi></msup><mi mathvariant="normal">∣</mi><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L = {0^n1^n| n \ge 0}</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="S \rightarrow 0S1 | \epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mn>0</mn><mi>S</mi><mn>1</mn><mi mathvariant="normal">∣</mi><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">S \rightarrow 0S1 | \epsilon</annotation></semantics></math></span></data></p>
<ul>
<li>A string <data class="katex-src" value="\beta \in (N \bigcup \Sigma^* )"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>N</mi><mo>⋃</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta \in (N \bigcup \Sigma^* )</annotation></semantics></math></span></data> is <em>derivable</em> from <data class="katex-src" value="\alpha \in&#10;  (N\bigcup \Sigma)^* "><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>N</mi><mo>⋃</mo><mi mathvariant="normal">Σ</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\alpha \in   (N\bigcup \Sigma)^* </annotation></semantics></math></span></data> if there is a production rule to substitute a
non-terminal in <data class="katex-src" value="\alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span></data> and get <data class="katex-src" value="\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span></data>.</li>
<li>A string in <data class="katex-src" value="(N\bigcup\Sigma)^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>⋃</mo><mi mathvariant="normal">Σ</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">(N\bigcup\Sigma)^*</annotation></semantics></math></span></data> is known as a <em>sentential form</em> if it is
derivable from S.</li>
<li>A string in <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data> is a <strong>sentence</strong> if it is derivable from <data class="katex-src" value="S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span></data>.</li>
</ul>
<p>Example: Dyck language (balanced parentheses)</p>
<p>[[][[]][[]]] is in L but []] is not</p>
<p><data class="katex-src" value="S \rightarrow [S] | SS | \epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mo stretchy="false">[</mo><mi>S</mi><mo stretchy="false">]</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">S \rightarrow [S] | SS | \epsilon</annotation></semantics></math></span></data></p>
<p><strong>Theorem:</strong> For a regular language <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data>, there exists grammar <data class="katex-src" value="G"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span></data> s.t.
<data class="katex-src" value="L = L(G)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L = L(G)</annotation></semantics></math></span></data></p>
<p>Construction:</p>
<p><data class="katex-src" value="\begin{align}&#10;\exists M = \left(Q,\Sigma, \delta, q_0, F\right) \\&#10;L(M) = L \\&#10;N = \{S_i | q_i \in Q\} \\&#10;S_i \rightarrow \sigma S_j \forall \delta(q_i, \sigma) = q_j \\&#10;q_i \in F \implies S_i \rightarrow \epsilon \\&#10;\end{align}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">∃</mi><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>N</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>S</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>q</mi><mi>i</mi></msub><mo>∈</mo><mi>Q</mi><mo stretchy="false">}</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>→</mo><mi>σ</mi><msub><mi>S</mi><mi>j</mi></msub><mi mathvariant="normal">∀</mi><mi>δ</mi><mo stretchy="false">(</mo><msub><mi>q</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>q</mi><mi>j</mi></msub></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>q</mi><mi>i</mi></msub><mo>∈</mo><mi>F</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><msub><mi>S</mi><mi>i</mi></msub><mo>→</mo><mi>ϵ</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} \exists M = \left(Q,\Sigma, \delta, q_0, F\right) \ L(M) = L \ N = {S_i | q_i \in Q} \ S_i \rightarrow \sigma S_j \forall \delta(q_i, \sigma) = q_j \ q_i \in F \implies S_i \rightarrow \epsilon \ \end{align}</annotation></semantics></math></span></data></p>
<p>Further proof:</p>
<ol>
<li><data class="katex-src" value="L(M) \subseteq L(G)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>L</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(M) \subseteq L(G)</annotation></semantics></math></span></data></li>
</ol>
<p>if <data class="katex-src" value="\hat{\delta}\left(q_i, w\right) = q_j"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>w</mi><mo fence="true">)</mo></mrow><mo>=</mo><msub><mi>q</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(q_i, w\right) = q_j</annotation></semantics></math></span></data> then <data class="katex-src" value="S_i"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i</annotation></semantics></math></span></data> goes to <data class="katex-src" value="wS_j"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><msub><mi>S</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">wS_j</annotation></semantics></math></span></data></p>
<p>Base case: <data class="katex-src" value="\hat{\delta}(q_i, \epsilon) = q_0"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msub><mi>q</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>ϵ</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\hat{\delta}(q_i, \epsilon) = q_0</annotation></semantics></math></span></data> then <data class="katex-src" value="S_i \rightarrow S_i"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>→</mo><msub><mi>S</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i \rightarrow S_i</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="\hat{\delta}(q_i, \sigma) = q_j"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msub><mi>q</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>q</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\hat{\delta}(q_i, \sigma) = q_j</annotation></semantics></math></span></data> then <data class="katex-src" value="\exists"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math></span></data> productions <data class="katex-src" value="S_i \rightarrow \sigma S_j"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>→</mo><mi>σ</mi><msub><mi>S</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">S_i \rightarrow \sigma S_j</annotation></semantics></math></span></data></p>
<ol start="2">
<li><data class="katex-src" value="L(G) \subseteq L(M)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>⊆</mo><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(G) \subseteq L(M)</annotation></semantics></math></span></data></li>
</ol>
<p>induct on the length of the derivation</p>
<h4 id="ambiguous-cfgs"><a class="header" href="#ambiguous-cfgs">Ambiguous CFGs</a></h4>
<p>These are those for which there are more than one parse trees. It is ambiguous
if it has more than one leftmost derivation. Use multiple rules to resolve
amiguousness.</p>
<p>However some languages are inherently ambiguous.</p>
<p><data class="katex-src" value="a^ib^jc^kd^l | i = j \land k = l \lor i = l \land j = k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>i</mi></msup><msup><mi>b</mi><mi>j</mi></msup><msup><mi>c</mi><mi>k</mi></msup><msup><mi>d</mi><mi>l</mi></msup><mi mathvariant="normal">∣</mi><mi>i</mi><mo>=</mo><mi>j</mi><mo>∧</mo><mi>k</mi><mo>=</mo><mi>l</mi><mo>∨</mo><mi>i</mi><mo>=</mo><mi>l</mi><mo>∧</mo><mi>j</mi><mo>=</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">a^ib^jc^kd^l | i = j \land k = l \lor i = l \land j = k</annotation></semantics></math></span></data></p>
<p>basically no possible grammar can make it unambiguous.</p>
<h4 id="closure-properties"><a class="header" href="#closure-properties">Closure properties</a></h4>
<p>Closed under union, concatenation, kleene closure.</p>
<p><strong>NOT CLOSED</strong> under intersection and complementation.</p>
<h4 id="chomsky-normal-form"><a class="header" href="#chomsky-normal-form">Chomsky Normal form</a></h4>
<p>A CFG G is in CNF if every production is of the form <data class="katex-src" value="A\rightarrow BC"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">A\rightarrow BC</annotation></semantics></math></span></data> or
<data class="katex-src" value="A\rightarrow \sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">A\rightarrow \sigma</annotation></semantics></math></span></data></p>
<p>CNF grammars do not generate <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data></p>
<ul>
<li>
<p>Remove <data class="katex-src" value="A\rightarrow \epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">A\rightarrow \epsilon</annotation></semantics></math></span></data></p>
<ul>
<li>For every production <data class="katex-src" value="B\rightarrow \alpha A\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>A</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">B\rightarrow \alpha A\beta</annotation></semantics></math></span></data>, add
<data class="katex-src" value="B\rightarrow \alpha\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>α</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">B\rightarrow \alpha\beta</annotation></semantics></math></span></data></li>
</ul>
</li>
<li>
<p>Remove <data class="katex-src" value="A\rightarrow B"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A\rightarrow B</annotation></semantics></math></span></data></p>
<ul>
<li><data class="katex-src" value="B\rightarrow \beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">B\rightarrow \beta</annotation></semantics></math></span></data> with <data class="katex-src" value="A\rightarrow \beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">A\rightarrow \beta</annotation></semantics></math></span></data></li>
</ul>
</li>
</ul>
<p>First remove all the <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> productions as they give more unit productions.</p>
<p>Then remove all unit productions.</p>
<p>This gives the minimum size grammar in CNF.</p>
<h4 id="pumping-lemma-1"><a class="header" href="#pumping-lemma-1">Pumping Lemma</a></h4>
<p>This is based on the fact that (almost) all languages are convertible to CNF.
If we have a path from the root node <data class="katex-src" value="S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span></data> to a leaf node in the parse tree that
is greater than <data class="katex-src" value="n +1"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n +1</annotation></semantics></math></span></data>, i.e., <data class="katex-src" value="|w| > 2^{n+1}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>w</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">|w| &gt; 2^{n+1}</annotation></semantics></math></span></data> where <data class="katex-src" value="w"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span></data> is the length of the
string and <data class="katex-src" value="n"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span></data> is the number of non-terminals in the productions.</p>
<p>By PHP, we can clearly see that a symbol is going to be repeated. So we can
repeat the entire length in the path, and the parse tree will still be valid.
This is the <em>pumping</em> we do.</p>
<p>For every CFL <data class="katex-src" value="L, \exists k > 0"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo separator="true">,</mo><mi mathvariant="normal">∃</mi><mi>k</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">L, \exists k &gt; 0</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="\forall z \in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\forall z \in L</annotation></semantics></math></span></data> s.t.
<data class="katex-src" value="|z| \ge k, \exists u,v,w,x,y"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi><mo>≥</mo><mi>k</mi><mo separator="true">,</mo><mi mathvariant="normal">∃</mi><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">|z| \ge k, \exists u,v,w,x,y</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="z = uvwxy"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>u</mi><mi>v</mi><mi>w</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">z = uvwxy</annotation></semantics></math></span></data> with <data class="katex-src" value="vx \ne \epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>x</mi><mo mathvariant="normal">≠</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">vx \ne \epsilon</annotation></semantics></math></span></data> and
<data class="katex-src" value="|vwx| \le k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>v</mi><mi>w</mi><mi>x</mi><mi mathvariant="normal">∣</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">|vwx| \le k</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="\forall i \ge 0 uv^iwx^iy \in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo>≥</mo><mn>0</mn><mi>u</mi><msup><mi>v</mi><mi>i</mi></msup><mi>w</mi><msup><mi>x</mi><mi>i</mi></msup><mi>y</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\forall i \ge 0 uv^iwx^iy \in L</annotation></semantics></math></span></data>.</p>
<p>Contrapositive form:</p>
<p>If <data class="katex-src" value="\forall k > 0, \exists z \in L; |z| \ge k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>k</mi><mo>&gt;</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∃</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mo separator="true">;</mo><mi mathvariant="normal">∣</mi><mi>z</mi><mi mathvariant="normal">∣</mi><mo>≥</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">\forall k &gt; 0, \exists z \in L; |z| \ge k</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="\forall u,z,w,x,y"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>u</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mi>w</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">\forall u,z,w,x,y</annotation></semantics></math></span></data> with
<data class="katex-src" value="vx \ne \epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>x</mi><mo mathvariant="normal">≠</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">vx \ne \epsilon</annotation></semantics></math></span></data> and <data class="katex-src" value="|vwx \le k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>v</mi><mi>w</mi><mi>x</mi><mo>≤</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">|vwx \le k</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="z=uvwxy"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi><mo>=</mo><mi>u</mi><mi>v</mi><mi>w</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">z=uvwxy</annotation></semantics></math></span></data>, <data class="katex-src" value="\exists i\ge 0"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>i</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\exists i\ge 0</annotation></semantics></math></span></data> s.t.
<data class="katex-src" value="uv^iwx^iy \notin L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><msup><mi>v</mi><mi>i</mi></msup><mi>w</mi><msup><mi>x</mi><mi>i</mi></msup><mi>y</mi><mo mathvariant="normal">∉</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">uv^iwx^iy \notin L</annotation></semantics></math></span></data> then L is not context—free.</p>
<p>Prover and Spoiler:</p>
<ul>
<li>
<p>Prover picks k &gt; 0</p>
</li>
<li>
<p>Spoiler chooses the string <data class="katex-src" value="z"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>z</mi></mrow><annotation encoding="application/x-tex">z</annotation></semantics></math></span></data></p>
</li>
<li>
<p>Prover chooses a split that he wants</p>
</li>
<li>
<p>Spoiler finds the i for which pumped string is outside the language.</p>
</li>
</ul>
<h4 id="parsing-algorithms-for-cfgs--cocke-kasami-younger"><a class="header" href="#parsing-algorithms-for-cfgs--cocke-kasami-younger">Parsing Algorithms for CFGs — Cocke Kasami Younger</a></h4>
<p>Assumptions: G is in CNF</p>
<p>Goal: Given <data class="katex-src" value="w \in \Sigma^* "><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">w \in \Sigma^* </annotation></semantics></math></span></data>, check if <data class="katex-src" value=" S \xrightarrow{\text{ * }} w "><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext> * </mtext></mpadded></mover><mi>w</mi></mrow><annotation encoding="application/x-tex"> S \xrightarrow{\text{ * }} w </annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="w = w_1w_2w_3\dots w_n"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo>=</mo><msub><mi>w</mi><mn>1</mn></msub><msub><mi>w</mi><mn>2</mn></msub><msub><mi>w</mi><mn>3</mn></msub><mo>…</mo><msub><mi>w</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">w = w_1w_2w_3\dots w_n</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="\exists A, B"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>A</mi><mo separator="true">,</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">\exists A, B</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="S\rightarrow AB, A \xrightarrow{\text{ * }} w_1w_2 \dots&#10;w_i, B \xrightarrow{\text{ * }} w_{i+1} w_{i+2} \dots w_n "><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>A</mi><mi>B</mi><mo separator="true">,</mo><mi>A</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext> * </mtext></mpadded></mover><msub><mi>w</mi><mn>1</mn></msub><msub><mi>w</mi><mn>2</mn></msub><mo>…</mo><msub><mi>w</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>B</mi><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext> * </mtext></mpadded></mover><msub><mi>w</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>w</mi><mrow><mi>i</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>…</mo><msub><mi>w</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">S\rightarrow AB, A \xrightarrow{\text{ * }} w_1w_2 \dots w_i, B \xrightarrow{\text{ * }} w_{i+1} w_{i+2} \dots w_n </annotation></semantics></math></span></data> for some
<data class="katex-src" value="1 \le i \le n"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \le i \le n</annotation></semantics></math></span></data></p>
<p>Try out all possible choices of <data class="katex-src" value="i"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span></data> and check if <data class="katex-src" value="A"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span></data> and <data class="katex-src" value="B"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span></data> match. This is
done recursively.</p>
<h4 id="push-down-automata-non-deterministic"><a class="header" href="#push-down-automata-non-deterministic">Push Down Automata (non-deterministic)</a></h4>
<p>Basically and NFA with a stack and a stack alphabet.</p>
<p><data class="katex-src" value="M = \left(Q, \Sigma, \Gamma, \delta, s, \perp, F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mo>⊥</mo><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M = \left(Q, \Sigma, \Gamma, \delta, s, \perp, F\right)</annotation></semantics></math></span></data></p>
<p>These are in the order = start state, alphabet of the string, alphabet of the
stack (string alphabet + non-terminals), transition function, initial state of
the stack, and the final states.</p>
<p><data class="katex-src" value="\delta \subseteq \left(Q\times \Sigma\cup \{\epsilon\}\times \Gamma\right)&#10;\times \left(Q\times \Gamma^*\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>⊆</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo>×</mo><mi mathvariant="normal">Σ</mi><mo>∪</mo><mo stretchy="false">{</mo><mi>ϵ</mi><mo stretchy="false">}</mo><mo>×</mo><mi mathvariant="normal">Γ</mi><mo fence="true">)</mo></mrow><mo>×</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo>×</mo><msup><mi mathvariant="normal">Γ</mi><mo>∗</mo></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\delta \subseteq \left(Q\times \Sigma\cup {\epsilon}\times \Gamma\right) \times \left(Q\times \Gamma^*\right)</annotation></semantics></math></span></data></p>
<p>If <data class="katex-src" value="\left(q, \sigma, A\right), \left(q', B_1B_2B_3\dots B_k\right) \in \delta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>σ</mi><mo separator="true">,</mo><mi>A</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mrow><mo fence="true">(</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msub><mi>B</mi><mn>1</mn></msub><msub><mi>B</mi><mn>2</mn></msub><msub><mi>B</mi><mn>3</mn></msub><mo>…</mo><msub><mi>B</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow><mo>∈</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">\left(q, \sigma, A\right), \left(q', B_1B_2B_3\dots B_k\right) \in \delta</annotation></semantics></math></span></data>
then we read <data class="katex-src" value="\sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span></data> from the string, pop <data class="katex-src" value="A"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span></data> from the stack, and push all
of <data class="katex-src" value="B_1B_2\dots B_k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>B</mi><mn>1</mn></msub><msub><mi>B</mi><mn>2</mn></msub><mo>…</mo><msub><mi>B</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">B_1B_2\dots B_k</annotation></semantics></math></span></data></p>
<p>If <data class="katex-src" value="\left(q, \epsilon, A\right), \left(q', B_1B_2B_3\dots B_k\right) \in \delta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>ϵ</mi><mo separator="true">,</mo><mi>A</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mrow><mo fence="true">(</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msub><mi>B</mi><mn>1</mn></msub><msub><mi>B</mi><mn>2</mn></msub><msub><mi>B</mi><mn>3</mn></msub><mo>…</mo><msub><mi>B</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow><mo>∈</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">\left(q, \epsilon, A\right), \left(q', B_1B_2B_3\dots B_k\right) \in \delta</annotation></semantics></math></span></data>
Read nothing but do the pushing and the popping.</p>
<p><strong>Acceptance</strong> happens when it reaches a final state on reading the entire
string.</p>
<p>Alternatively, <strong>empty stack acceptance</strong> happens when the string becomes empty
and makes the stack empty as well.</p>
<h4 id="converting-cfgs-to-pdas"><a class="header" href="#converting-cfgs-to-pdas">Converting CFGs to PDAs</a></h4>
<p><data class="katex-src" value="G = \left(N, \Sigma, P, S\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>N</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">G = \left(N, \Sigma, P, S\right)</annotation></semantics></math></span></data></p>
<p>Define <data class="katex-src" value="\Gamma = N\cup\Sigma\cup\{\perp\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>=</mo><mi>N</mi><mo>∪</mo><mi mathvariant="normal">Σ</mi><mo>∪</mo><mo stretchy="false">{</mo><mo>⊥</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Gamma = N\cup\Sigma\cup{\perp}</annotation></semantics></math></span></data></p>
<p>For a production <data class="katex-src" value="A \rightarrow \alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">A \rightarrow \alpha</annotation></semantics></math></span></data>, add stack transition
<data class="katex-src" value="\epsilon, A \rightarrow \alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo separator="true">,</mo><mi>A</mi><mo>→</mo><mi>α</mi></mrow><annotation encoding="application/x-tex">\epsilon, A \rightarrow \alpha</annotation></semantics></math></span></data></p>
<p>Add transition <data class="katex-src" value="\epsilon, \perp \rightarrow S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo separator="true">,</mo><mo>⊥</mo><mo>→</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\epsilon, \perp \rightarrow S</annotation></semantics></math></span></data></p>
<p>Add transition <data class="katex-src" value="\sigma, \sigma \rightarrow \epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo separator="true">,</mo><mi>σ</mi><mo>→</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\sigma, \sigma \rightarrow \epsilon</annotation></semantics></math></span></data></p>
<p>This PDA obviously accepts the CFG using empty staack acceptance as a basis.</p>
<h4 id="converting-from-pdas-to-cfgs"><a class="header" href="#converting-from-pdas-to-cfgs">Converting from PDAs to CFGs</a></h4>
<blockquote>
<p>TL;DR: Absolute pain in the ass</p>
</blockquote>
<p>If you have a PDA with a single state that accepts using an empty stack:</p>
<p>If <data class="katex-src" value="\left(\left(q,\sigma, A\right), \left(q, B_1B_2\dots B_k\right)\right)&#10;\in\delta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">(</mo><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>σ</mi><mo separator="true">,</mo><mi>A</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><msub><mi>B</mi><mn>1</mn></msub><msub><mi>B</mi><mn>2</mn></msub><mo>…</mo><msub><mi>B</mi><mi>k</mi></msub><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow><mo>∈</mo><mi>δ</mi></mrow><annotation encoding="application/x-tex">\left(\left(q,\sigma, A\right), \left(q, B_1B_2\dots B_k\right)\right) \in\delta</annotation></semantics></math></span></data> then add the production <data class="katex-src" value="A\rightarrow\sigma B-1B_2\dots B_k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>σ</mi><mi>B</mi><mo>−</mo><mn>1</mn><msub><mi>B</mi><mn>2</mn></msub><mo>…</mo><msub><mi>B</mi><mi>k</mi></msub></mrow><annotation encoding="application/x-tex">A\rightarrow\sigma B-1B_2\dots B_k</annotation></semantics></math></span></data></p>
<p>To convert a general PDA with a single final state to a PDA that accepts with
the empty stack:</p>
<p>Let <data class="katex-src" value="M = \left(Q, \Sigma, \Gamma, \delta, s, \perp, \{f\}\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mo>⊥</mo><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>f</mi><mo stretchy="false">}</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M = \left(Q, \Sigma, \Gamma, \delta, s, \perp, {f}\right)</annotation></semantics></math></span></data></p>
<p>We define <data class="katex-src" value="M' = \left({q}, \Sigma, \Gamma', \delta', \{q\},&#10;\left(s, \perp, f\right), \phi\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><msup><mi mathvariant="normal">Γ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>δ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>q</mi><mo stretchy="false">}</mo><mo separator="true">,</mo><mrow><mo fence="true">(</mo><mi>s</mi><mo separator="true">,</mo><mo>⊥</mo><mo separator="true">,</mo><mi>f</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>ϕ</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M' = \left({q}, \Sigma, \Gamma', \delta', {q}, \left(s, \perp, f\right), \phi\right)</annotation></semantics></math></span></data></p>
<p>Here <data class="katex-src" value="\Gamma' = Q\times\Gamma\times Q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Γ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>Q</mi><mo>×</mo><mi mathvariant="normal">Γ</mi><mo>×</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">\Gamma' = Q\times\Gamma\times Q</annotation></semantics></math></span></data></p>
<p>Over here, both the Q’s are guesses for us,</p>
<!---TODO: Fill the details  --->
<h3 id="effective-computability"><a class="header" href="#effective-computability">Effective Computability</a></h3>
<p>Multiple notions of effective computability:</p>
<ul>
<li><data class="katex-src" value="\lambda"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">\lambda</annotation></semantics></math></span></data> calculus</li>
<li><data class="katex-src" value="\mu"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span></data> recursive functions</li>
<li>Turing Machines</li>
</ul>
<p><strong>Church Turing thesis</strong>: Any physically reaslisable computationally device
can be simulated by a Turing machine.</p>
<h4 id="turing-machines"><a class="header" href="#turing-machines">Turing Machines</a></h4>
<p><data class="katex-src" value="M  = \left(Q, \Sigma, \Gamma, \vdash, \circ, \delta, s, t, r\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mo>⊢</mo><mo separator="true">,</mo><mo>∘</mo><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>t</mi><mo separator="true">,</mo><mi>r</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M  = \left(Q, \Sigma, \Gamma, \vdash, \circ, \delta, s, t, r\right)</annotation></semantics></math></span></data></p>
<p>These are in the order state, string alphabet, tape alphabet, left end of the
tape, blank symbol on the tape, transition, accept state and reject state.</p>
<p><data class="katex-src" value="\delta: Q\times \Gamma \rightarrow Q\times\Gamma\times\{L,R\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mi>Q</mi><mo>×</mo><mi mathvariant="normal">Γ</mi><mo>→</mo><mi>Q</mi><mo>×</mo><mi mathvariant="normal">Γ</mi><mo>×</mo><mo stretchy="false">{</mo><mi>L</mi><mo separator="true">,</mo><mi>R</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\delta: Q\times \Gamma \rightarrow Q\times\Gamma\times{L,R}</annotation></semantics></math></span></data> where the first
parentheses denotes the current state and the current symbol under the tape.</p>
<p>The right parentheses tells you the next state to go to, and the symbol to be
written, and whether to move left or right.</p>
<p>Constraints:</p>
<ul>
<li>If you are on the left delimiter of the tape you can only move to the right.</li>
<li>If you are on the accept/reject states, you are stuck there.</li>
</ul>
<p>Configurations of a Turing Machine: <data class="katex-src" value="Q\times \Gamma^* \times \mathbb{N}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>×</mo><msup><mi mathvariant="normal">Γ</mi><mo>∗</mo></msup><mo>×</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex">Q\times \Gamma^* \times \mathbb{N}</annotation></semantics></math></span></data>. These
are, in order, current state, tape content, and the position of the tape head.</p>
<ul>
<li>Initial contents are <data class="katex-src" value="\left(s, \vdash x, 0\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mi>s</mi><mo separator="true">,</mo><mo>⊢</mo><mi>x</mi><mo separator="true">,</mo><mn>0</mn><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(s, \vdash x, 0\right)</annotation></semantics></math></span></data></li>
<li>Acceptance happens when <data class="katex-src" value="\left(s,\perp x, 0\right) \xrightarrow{\text{ * }}&#10;  \left(t, y, m\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">(</mo><mi>s</mi><mo separator="true">,</mo><mo>⊥</mo><mi>x</mi><mo separator="true">,</mo><mn>0</mn><mo fence="true">)</mo></mrow><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext> * </mtext></mpadded></mover><mrow><mo fence="true">(</mo><mi>t</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>m</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(s,\perp x, 0\right) \xrightarrow{\text{ * }}   \left(t, y, m\right)</annotation></semantics></math></span></data></li>
<li>Rejection happens when <data class="katex-src" value="\left(s, \perp s, 0\right) \xrightarrow{\text{ * }}&#10;  \left(r, y, n\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">(</mo><mi>s</mi><mo separator="true">,</mo><mo>⊥</mo><mi>s</mi><mo separator="true">,</mo><mn>0</mn><mo fence="true">)</mo></mrow><mover><mo stretchy="true" minsize="3.0em">→</mo><mpadded width="+0.6em" lspace="0.3em"><mtext> * </mtext></mpadded></mover><mrow><mo fence="true">(</mo><mi>r</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>n</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(s, \perp s, 0\right) \xrightarrow{\text{ * }}   \left(r, y, n\right)</annotation></semantics></math></span></data></li>
</ul>
<p>An accepted language by a turing machine is called <em>recursively enumerable</em>
(re). If it is a total turing machine then it is called <em>recursive</em>.</p>
<p>A <em>total turing machine</em> is one that eithers accepts a string or rejects a
string. There is no string on which it never accepts and never rejects.
(Basically loops forever on the tape)</p>
<p>A <em>Multi tape turing machine</em>, as it sounds, is a Turing Machine with multiple
tapes. It is also possible to simulate a multi tape turing machine using a
Turing Machine with a single tape.</p>
<p>Rough outline of how it happens:</p>
<ul>
<li>The number of tapes is <data class="katex-src" value="k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span></data>, and the number of states is <data class="katex-src" value="S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span></data>, and the size of
the alphabet is <data class="katex-src" value="|\Sigma|"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi mathvariant="normal">Σ</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|\Sigma|</annotation></semantics></math></span></data>.</li>
<li>Our new Turing Machine has <data class="katex-src" value="\left|\Sigma\right|^k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo fence="true">∣</mo><mi mathvariant="normal">Σ</mi><mo fence="true">∣</mo></mrow><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">\left|\Sigma\right|^k</annotation></semantics></math></span></data> pre filled tape cells.</li>
<li>The tape alphabet is also enlarged similarly.</li>
<li>The characters are now encoded in the new tape in such a way that it contains
all possible combinations of the first tape characters in index 0, second
tape characters in index 1, and so on.</li>
<li>Finally, in a transition, it sweeps across the entire tape and finds where
the character is.</li>
<li>Once that happens, the tape head sweeps backwards to update the letters that
were updated.</li>
</ul>
<p>A <em>Universal Turing Machine</em> has 3 tapes, one for the encoding of the TM it is
trying to simulate, one for the tape of TM it is simulating, and one to store
the states and positions of said turing machines.</p>
<p>Theorem: <data class="katex-src" value="\exists"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi></mrow><annotation encoding="application/x-tex">\exists</annotation></semantics></math></span></data> a universal TM</p>
<p><strong>Membership Problem</strong>: Given a TM <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> and <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data>, check if <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> accepts <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data>.</p>
<p>The language of this problem is <em>r.e.</em> (this is a <strong>fact</strong>).</p>
<p><strong>Halting Problem</strong>: Check if <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> halts on <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data>.</p>
<p>The language of this problem is <em>r.e.</em> (this is a <strong>fact</strong>).</p>
<p>Property:
If <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data> is both r.e. and co-r.e., then it is recursive. (co-r.e. means
complement is recursive)</p>
<p>Proof: Simulate both on a single turing machine. Whichever accepts, halt and
accept/reject accordingly.</p>
<h4 id="enumeration-machines"><a class="header" href="#enumeration-machines">Enumeration Machines</a></h4>
<p>These have no input, there is no need to halt, one work
tape and one output tape, there is a special print state that prints the
contents of the output tape, clears it and then exits the state.</p>
<p>A language is r.e. <strong>iff</strong> there exists an E.M. for it. This is equivalent to a
time sharing simulation of M.</p>
<h4 id="undecidability-and-diagonalization"><a class="header" href="#undecidability-and-diagonalization">Undecidability and Diagonalization</a></h4>
<p><strong>Theorem(Turing):</strong> HP is not recursive.</p>
<p>Let <data class="katex-src" value="M_x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">M_x</annotation></semantics></math></span></data> be the Turing Machine that is encoded by the string <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data>. If no such
thing exists, then let it be the trivial TM accepting everything.</p>
<p>This way, we get a list of turing machines. Let us assume that this is the
complete list of turing machines.</p>
<p>Now consider a 2D matrix containing strings <data class="katex-src" value="y"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span></data> in the row header and TMs <data class="katex-src" value="M_x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">M_x</annotation></semantics></math></span></data>
in the column header. The cell says H if the machine halts on the string and
L if it loops forever. If our assumption that the list of turing machines being
complete is true, then we can always do this table.</p>
<p>Suppose there is a universal Turing machine <data class="katex-src" value="K"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span></data> that halts and accepts if <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data>
halts on <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> and halts and rejects if <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> loops on <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data>.</p>
<p>Consider a universal machine <data class="katex-src" value="N"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></data> that takes input <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> and runs <data class="katex-src" value="K"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span></data> on
<data class="katex-src" value="(M_x,x)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>M</mi><mi>x</mi></msub><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(M_x,x)</annotation></semantics></math></span></data>. If <data class="katex-src" value="K"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span></data> rejects the input then <data class="katex-src" value="N"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></data> accepts it and if <data class="katex-src" value="K"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span></data> accepts it
then <data class="katex-src" value="N"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></data> goes into a loop.</p>
<p>If <data class="katex-src" value="N"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></data> halts on <data class="katex-src" value="x \Longleftrightarrow K"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>⟺</mo><mi>K</mi></mrow><annotation encoding="application/x-tex">x \Longleftrightarrow K</annotation></semantics></math></span></data> rejects <data class="katex-src" value="(M_x,x) \Longleftrightarrow&#10;M_x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>M</mi><mi>x</mi></msub><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>⟺</mo><msub><mi>M</mi><mi>x</mi></msub></mrow><annotation encoding="application/x-tex">(M_x,x) \Longleftrightarrow M_x</annotation></semantics></math></span></data> loops on <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data>. This implies that <data class="katex-src" value="N"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></data> differs from each row of the table
at the diagonal. However the list contained every Turing Machine in existence,
so the assumption that the table entries are determinable is wrong.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../notes/cp_qs_reading.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../notes/cs2600.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../notes/cp_qs_reading.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../notes/cs2600.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
