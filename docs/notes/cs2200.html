<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>./notes/cs2200.md - Notes</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././src/notes/custom.css">
        <link rel="stylesheet" href=".././src/notes/katex.min.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../notes/algorithms.html"><strong aria-hidden="true">1.</strong> ./notes/algorithms.md</a></li><li class="chapter-item "><a href="../notes/arp.html"><strong aria-hidden="true">2.</strong> ./notes/arp.md</a></li><li class="chapter-item "><a href="../notes/asm.html"><strong aria-hidden="true">3.</strong> ./notes/asm.md</a></li><li class="chapter-item "><a href="../notes/basic_preproc.html"><strong aria-hidden="true">4.</strong> ./notes/basic_preproc.md</a></li><li class="chapter-item "><a href="../notes/boost_asio.html"><strong aria-hidden="true">5.</strong> ./notes/boost_asio.md</a></li><li class="chapter-item "><a href="../notes/c_codes.html"><strong aria-hidden="true">6.</strong> ./notes/c_codes.md</a></li><li class="chapter-item "><a href="../notes/classes.html"><strong aria-hidden="true">7.</strong> ./notes/classes.md</a></li><li class="chapter-item "><a href="../notes/cmake.html"><strong aria-hidden="true">8.</strong> ./notes/cmake.md</a></li><li class="chapter-item "><a href="../notes/C_notes.html"><strong aria-hidden="true">9.</strong> ./notes/C_notes.md</a></li><li class="chapter-item "><a href="../notes/compilers.html"><strong aria-hidden="true">10.</strong> ./notes/compilers.md</a></li><li class="chapter-item "><a href="../notes/concurrency.html"><strong aria-hidden="true">11.</strong> ./notes/concurrency.md</a></li><li class="chapter-item "><a href="../notes/cont_struct.html"><strong aria-hidden="true">12.</strong> ./notes/cont_struct.md</a></li><li class="chapter-item "><a href="../notes/cp_codes.html"><strong aria-hidden="true">13.</strong> ./notes/cp_codes.md</a></li><li class="chapter-item "><a href="../notes/cpp_guidelines.html"><strong aria-hidden="true">14.</strong> ./notes/cpp_guidelines.md</a></li><li class="chapter-item "><a href="../notes/cpp.html"><strong aria-hidden="true">15.</strong> ./notes/cpp.md</a></li><li class="chapter-item "><a href="../notes/cp_qs_models.html"><strong aria-hidden="true">16.</strong> ./notes/cp_qs_models.md</a></li><li class="chapter-item "><a href="../notes/cp_qs_reading.html"><strong aria-hidden="true">17.</strong> ./notes/cp_qs_reading.md</a></li><li class="chapter-item expanded "><a href="../notes/cs2200.html" class="active"><strong aria-hidden="true">18.</strong> ./notes/cs2200.md</a></li><li class="chapter-item "><a href="../notes/cs2600.html"><strong aria-hidden="true">19.</strong> ./notes/cs2600.md</a></li><li class="chapter-item "><a href="../notes/csd.html"><strong aria-hidden="true">20.</strong> ./notes/csd.md</a></li><li class="chapter-item "><a href="../notes/cv_qualifiers.html"><strong aria-hidden="true">21.</strong> ./notes/cv_qualifiers.md</a></li><li class="chapter-item "><a href="../notes/data_structures.html"><strong aria-hidden="true">22.</strong> ./notes/data_structures.md</a></li><li class="chapter-item "><a href="../notes/data_types.html"><strong aria-hidden="true">23.</strong> ./notes/data_types.md</a></li><li class="chapter-item "><a href="../notes/dhcp.html"><strong aria-hidden="true">24.</strong> ./notes/dhcp.md</a></li><li class="chapter-item "><a href="../notes/dhcpv6.html"><strong aria-hidden="true">25.</strong> ./notes/dhcpv6.md</a></li><li class="chapter-item "><a href="../notes/dns.html"><strong aria-hidden="true">26.</strong> ./notes/dns.md</a></li><li class="chapter-item "><a href="../notes/enum_classes.html"><strong aria-hidden="true">27.</strong> ./notes/enum_classes.md</a></li><li class="chapter-item "><a href="../notes/file_descriptors.html"><strong aria-hidden="true">28.</strong> ./notes/file_descriptors.md</a></li><li class="chapter-item "><a href="../notes/functions.html"><strong aria-hidden="true">29.</strong> ./notes/functions.md</a></li><li class="chapter-item "><a href="../notes/gdb.html"><strong aria-hidden="true">30.</strong> ./notes/gdb.md</a></li><li class="chapter-item "><a href="../notes/hacking_basics.html"><strong aria-hidden="true">31.</strong> ./notes/hacking_basics.md</a></li><li class="chapter-item "><a href="../notes/icmp.html"><strong aria-hidden="true">32.</strong> ./notes/icmp.md</a></li><li class="chapter-item "><a href="../notes/if_else_loops.html"><strong aria-hidden="true">33.</strong> ./notes/if_else_loops.md</a></li><li class="chapter-item "><a href="../notes/io.html"><strong aria-hidden="true">34.</strong> ./notes/io.md</a></li><li class="chapter-item "><a href="../notes/ipv4.html"><strong aria-hidden="true">35.</strong> ./notes/ipv4.md</a></li><li class="chapter-item "><a href="../notes/ipv6.html"><strong aria-hidden="true">36.</strong> ./notes/ipv6.md</a></li><li class="chapter-item "><a href="../notes/jpeg.html"><strong aria-hidden="true">37.</strong> ./notes/jpeg.md</a></li><li class="chapter-item "><a href="../notes/memory.html"><strong aria-hidden="true">38.</strong> ./notes/memory.md</a></li><li class="chapter-item "><a href="../notes/natas_levels.html"><strong aria-hidden="true">39.</strong> ./notes/natas_levels.md</a></li><li class="chapter-item "><a href="../notes/network_stack.html"><strong aria-hidden="true">40.</strong> ./notes/network_stack.md</a></li><li class="chapter-item "><a href="../notes/poe.html"><strong aria-hidden="true">41.</strong> ./notes/poe.md</a></li><li class="chapter-item "><a href="../notes/pointers.html"><strong aria-hidden="true">42.</strong> ./notes/pointers.md</a></li><li class="chapter-item "><a href="../notes/project_euler.html"><strong aria-hidden="true">43.</strong> ./notes/project_euler.md</a></li><li class="chapter-item "><a href="../notes/python.html"><strong aria-hidden="true">44.</strong> ./notes/python.md</a></li><li class="chapter-item "><a href="../notes/references.html"><strong aria-hidden="true">45.</strong> ./notes/references.md</a></li><li class="chapter-item "><a href="../notes/regex.html"><strong aria-hidden="true">46.</strong> ./notes/regex.md</a></li><li class="chapter-item "><a href="../notes/registers.html"><strong aria-hidden="true">47.</strong> ./notes/registers.md</a></li><li class="chapter-item "><a href="../notes/rust_notes.html"><strong aria-hidden="true">48.</strong> ./notes/rust_notes.md</a></li><li class="chapter-item "><a href="../notes/rvalue_refs.html"><strong aria-hidden="true">49.</strong> ./notes/rvalue_refs.md</a></li><li class="chapter-item "><a href="../notes/static_variables_and_functions.html"><strong aria-hidden="true">50.</strong> ./notes/static_variables_and_functions.md</a></li><li class="chapter-item "><a href="../notes/std_forward.html"><strong aria-hidden="true">51.</strong> ./notes/std_forward.md</a></li><li class="chapter-item "><a href="../notes/strings_arrays.html"><strong aria-hidden="true">52.</strong> ./notes/strings_arrays.md</a></li><li class="chapter-item "><a href="../notes/tcp.html"><strong aria-hidden="true">53.</strong> ./notes/tcp.md</a></li><li class="chapter-item "><a href="../notes/traceroute.html"><strong aria-hidden="true">54.</strong> ./notes/traceroute.md</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cs2200"><a class="header" href="#cs2200">cs2200</a></h1>
<p>Types of grammar:</p>
<ol>
<li>Right linear</li>
<li>Context free</li>
<li>unrestricted</li>
</ol>
<p>Types of machine models:</p>
<ol>
<li>finite memory: finite automata, regex</li>
<li>finite memory with stack: pushdown automata</li>
<li>unrestricted: turing machines, post systems, λ calculus etc.</li>
</ol>
<p>There is a one to one correspondence for the numberings above.</p>
<blockquote>
<p>Gödel’s incompleteness theorem: No matter how strong a deductive system is,
there are always statements that are true but unprovable.</p>
</blockquote>
<h2 id="strings-and-sets"><a class="header" href="#strings-and-sets">Strings and Sets</a></h2>
<blockquote>
<p><em>Decision problem</em> is a function that has a one bit output: true or false,
1 or 0.</p>
</blockquote>
<p>To completely specify a decision problem, specify a set of possible inputs, and
the subset for which the output is true.</p>
<p>Encoding the input of a decision problem as a fixed finite length string is
possible over some fixed finite alphabet.</p>
<blockquote>
<p>A <strong>finite alphabet</strong> is any finite set. A finite length string is a
sequence of the elements.</p>
</blockquote>
<p>Set ops for two sets:</p>
<ul>
<li>Union</li>
<li>Intersection</li>
<li>Complement over set of all strings: Basically, it depends on the <strong>set of
all strings</strong> that is chosen and hence this is often written as
<data class="katex-src" value="\Sigma^* — A"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mtext>—</mtext><mi>A</mi></mrow><annotation encoding="application/x-tex">\Sigma^* — A</annotation></semantics></math></span></data> to emphasize this.</li>
<li>Concatenation of two sets: <data class="katex-src" value="AB = \{xy | x \in A; y \in B\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo>∈</mo><mi>A</mi><mo separator="true">;</mo><mi>y</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">AB = {xy | x \in A; y \in B}</annotation></semantics></math></span></data>.</li>
</ul>
<p>Set ops on one set:</p>
<ul>
<li><em>asterate</em> A<sup>*</sup> of a set. <data class="katex-src" value="A^* = \bigcup_{n\geq 0}A^n"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><msub><mo>⋃</mo><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow></msub><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">A^* = \bigcup_{n\geq 0}A^n</annotation></semantics></math></span></data></li>
<li>A<sup>+</sup> of a set. <data class="katex-src" value="A^+ = \bigcup_{n \geq 1}A^n"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>+</mo></msup><mo>=</mo><msub><mo>⋃</mo><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow></msub><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">A^+ = \bigcup_{n \geq 1}A^n</annotation></semantics></math></span></data>.</li>
</ul>
<h2 id="states-and-transitions"><a class="header" href="#states-and-transitions">States and transitions</a></h2>
<p>A <strong>state</strong> of a system gives all the relevant information of a system, like a
<em>snapshot</em>. <strong>Transitions</strong> are changes of states.</p>
<p>If both are finite, then the system is called a
<em>finite state transition</em> system. We model them using <em>finite automata</em>.</p>
<h3 id="deterministic-finite-automata"><a class="header" href="#deterministic-finite-automata">Deterministic Finite Automata</a></h3>
<p>Formally,</p>
<p><data class="katex-src" value="M = \left(Q,\Sigma,\delta,s,F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M = \left(Q,\Sigma,\delta,s,F\right)</annotation></semantics></math></span></data></p>
<ul>
<li><em>Q</em> is the finite set of states.</li>
<li><data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data> is the finite set of the input <em>alphabet</em>.</li>
<li><data class="katex-src" value="\delta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span></data> is the transition function that takes the current state and the
input <em>character</em> as the inputs and gives the next state as the output.</li>
<li><em>s</em> is the start state.</li>
<li><em>F</em> is the finite subset of <em>Q</em> that are acceptable as the final states.</li>
</ul>
<p>To extend the character input to a <em>string</em>, we define <data class="katex-src" value="\hat{\delta}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\delta}</annotation></semantics></math></span></data>
inductively as follows:</p>
<ul>
<li><data class="katex-src" value="\hat{\delta}\left(q, xa\right) = \delta\left(\hat{\delta}\left(q, x\right),&#10;  a\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>x</mi><mi>a</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>δ</mi><mrow><mo fence="true">(</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(q, xa\right) = \delta\left(\hat{\delta}\left(q, x\right),   a\right)</annotation></semantics></math></span></data></li>
<li><data class="katex-src" value="\hat{\delta}\left(q, \epsilon\right) = q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>ϵ</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(q, \epsilon\right) = q</annotation></semantics></math></span></data></li>
</ul>
<p>Where <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> is a <em>string</em>, <data class="katex-src" value="a"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></data> is a character, and <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> is the empty input.</p>
<p>These can also be translated to the finite state machines
<a href="./csd.html#finite-state-machines">discussed here</a>.</p>
<p>A string <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> is accepted by an automation <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> if</p>
<p><data class="katex-src" value="\hat{\delta}\left(s,x\right) \in F"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>s</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>∈</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(s,x\right) \in F</annotation></semantics></math></span></data></p>
<p>A <em>set</em> or a <em>language</em> accepted by <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> is the set of all strings
accepted by some automata <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data>, also called <data class="katex-src" value="L(M)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(M)</annotation></semantics></math></span></data>. Any subset of <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data>
is said to be regular if it is accepted by some automaton <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data>.</p>
<p><strong>Any</strong> <em>finite</em> subset of <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data> is regular (brute-force all strings).</p>
<blockquote>
<p>Proof that union of two regular languages is regular:</p>
</blockquote>
<p>Let DFA 1 be <data class="katex-src" value="\left(Q_1, \Sigma, \delta_1, s_1, F_1\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><msub><mi>Q</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><msub><mi>δ</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>F</mi><mn>1</mn></msub><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(Q_1, \Sigma, \delta_1, s_1, F_1\right)</annotation></semantics></math></span></data> and DFA 2 be
<data class="katex-src" value="\left(Q_2, \Sigma, \delta_2, s_2, F_2\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><msub><mi>Q</mi><mn>2</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><msub><mi>δ</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>F</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(Q_2, \Sigma, \delta_2, s_2, F_2\right)</annotation></semantics></math></span></data></p>
<p>The final automata has the cartesian product of the two sets of states as the
set of states (Q), and the delta is also from Q1 x Q2 to Q1 x Q2. The set of
final states is <data class="katex-src" value="Q_1\times F_2 \cup Q_2 \times F_1"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mn>1</mn></msub><mo>×</mo><msub><mi>F</mi><mn>2</mn></msub><mo>∪</mo><msub><mi>Q</mi><mn>2</mn></msub><mo>×</mo><msub><mi>F</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">Q_1\times F_2 \cup Q_2 \times F_1</annotation></semantics></math></span></data>. Also,
<data class="katex-src" value="\hat{\delta}\left(\left(s_1, s_2\right), w\right) =&#10;\left(\hat{\delta}\left(s_1, w\right),\hat{\delta}\left(s_2, w\right)\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mrow><mo fence="true">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>s</mi><mn>2</mn></msub><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>w</mi><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>w</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>s</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>w</mi><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(\left(s_1, s_2\right), w\right) = \left(\hat{\delta}\left(s_1, w\right),\hat{\delta}\left(s_2, w\right)\right)</annotation></semantics></math></span></data></p>
<blockquote>
<p>Proof the the complement of a regular language is also regular:</p>
</blockquote>
<p>All accepted final states become non-accepted, while all non-accepted final
states become accepted.</p>
<blockquote>
<p>Proof that the intersection of two regular languages is also regular:</p>
</blockquote>
<p>Using set properties (De Morgan’s Law), or instead follow the proof of
union and replace the final set with <data class="katex-src" value="F_1 \times F_2"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>F</mi><mn>1</mn></msub><mo>×</mo><msub><mi>F</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">F_1 \times F_2</annotation></semantics></math></span></data>.</p>
<h3 id="non-deterministic-finite-automata"><a class="header" href="#non-deterministic-finite-automata">Non-deterministic Finite Automata</a></h3>
<p>A finite automata where the next state is not necessarily determined by the
current state, and the input symbol. It is effectively in a
state of <em>guessing</em>.</p>
<p>To show that an automata accepts a set <data class="katex-src" value="B"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span></data>, we argue that there exists a
lucky sequence of guesses that lead from the start state to an accept state
when the end of <data class="katex-src" value="x\in B"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">x\in B</annotation></semantics></math></span></data> is reached, but for any string outside the set,
it is impossible.</p>
<p>Formally,</p>
<p><data class="katex-src" value="M = \left(Q,\Sigma,\Delta,S,F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M = \left(Q,\Sigma,\Delta,S,F\right)</annotation></semantics></math></span></data></p>
<ul>
<li><em>Q</em> is the finite set of states.</li>
<li><data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data> is the finite set of the input <em>alphabet</em>.</li>
<li><data class="katex-src" value="\Delta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span></data> is the transition function that takes the current state and the
input <em>character</em> as the inputs and gives the next state as the output.
In this case, there are <data class="katex-src" value="2^Q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">2^Q</annotation></semantics></math></span></data> possible outputs, instead of the
<data class="katex-src" value="Q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span></data> possible outputs in case of DFA. Each output corresponds to a unique
element in the power set of <data class="katex-src" value="Q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span></data>.</li>
<li><em>S</em> is the subset of acceptable states called the start states.</li>
<li><em>F</em> is the finite subset of <em>Q</em> that are acceptable as the final states.</li>
</ul>
<p>To define the acceptance, we use the following rules:</p>
<p><data class="katex-src" value="\hat{\Delta}\left(A,\epsilon\right) = A"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>ϵ</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\hat{\Delta}\left(A,\epsilon\right) = A</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="\hat{\Delta}\left(A, xa\right) = \bigcup_{q\in \hat{\Delta}\left(A,x\right)} &#10;\Delta\left(q,a\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mi>a</mi><mo fence="true">)</mo></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><mi>q</mi><mo>∈</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow></munder><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\Delta}\left(A, xa\right) = \bigcup_{q\in \hat{\Delta}\left(A,x\right)}  \Delta\left(q,a\right)</annotation></semantics></math></span></data></p>
<p>Instead of the usual one state, we have the input to be a subset of the
possible state for <data class="katex-src" value="\hat{\Delta}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\Delta}</annotation></semantics></math></span></data>.</p>
<p>Acceptance happens when <data class="katex-src" value="x \in \Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x \in \Sigma^*</annotation></semantics></math></span></data> satisfies <data class="katex-src" value="\hat{\Delta}&#10;\left(S,x\right) \cap F \neq \phi"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>S</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>∩</mo><mi>F</mi><mo mathvariant="normal">≠</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\hat{\Delta} \left(S,x\right) \cap F \neq \phi</annotation></semantics></math></span></data></p>
<p>Proof for Deterministic and Non-deterministic Finite Automata being equivalent:</p>
<ul>
<li>First we prove that <data class="katex-src" value="\hat{\Delta}\left(A, xy\right) =&#10;  \hat{\Delta}\left(\hat{\Delta}\left(A, x\right), y\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mi>y</mi><mo fence="true">)</mo></mrow><mo>=</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>y</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\Delta}\left(A, xy\right) =   \hat{\Delta}\left(\hat{\Delta}\left(A, x\right), y\right)</annotation></semantics></math></span></data></li>
</ul>
<p>Induction on |y|:</p>
<p>For |y| = 0, it is trivially true from the above equations.</p>
<p>Assume for |y| ≤ n,</p>
<p><data class="katex-src" value="&#10;\begin{align*}&#10;\hat{\Delta}\left(A, xya\right) &= \bigcup_{q\in \hat{\Delta}\left(A,xy\right)} &#10;\Delta\left(q,a\right) \\&#10;& = \bigcup_{q\in \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),y\right)} &#10;\Delta\left(q,a\right) \\&#10;& = \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),ya\right)&#10;\end{align*}&#10;"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mi>y</mi><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><mi>q</mi><mo>∈</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mi>y</mi><mo fence="true">)</mo></mrow></mrow></munder><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><mi>q</mi><mo>∈</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>y</mi><mo fence="true">)</mo></mrow></mrow></munder><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>y</mi><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{align*} \hat{\Delta}\left(A, xya\right) &amp;= \bigcup_{q\in \hat{\Delta}\left(A,xy\right)}  \Delta\left(q,a\right) \ &amp; = \bigcup_{q\in \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),y\right)}  \Delta\left(q,a\right) \ &amp; = \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),ya\right) \end{align*} </annotation></semantics></math></span></data></p>
<ul>
<li>Second, the function <data class="katex-src" value="\hat{\Delta}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\Delta}</annotation></semantics></math></span></data> commutes with the set union, i.e.,
<data class="katex-src" value="\hat{\Delta}(\bigcup_i A_i,x) = \bigcup_i \hat{\Delta}(A_i, x)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msub><mo>⋃</mo><mi>i</mi></msub><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>⋃</mo><mi>i</mi></msub><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{\Delta}(\bigcup_i A_i,x) = \bigcup_i \hat{\Delta}(A_i, x)</annotation></semantics></math></span></data></li>
</ul>
<p>Induction on |x|:</p>
<p>For |x| = 0, it is trivially true.</p>
<p>Assume for |x| ≤ n.</p>
<p><data class="katex-src" value="&#10;\begin{align*}&#10;\hat{\Delta}\left(\bigcup_i A_i, xa\right) & = &#10;\hat{\Delta}\left(\hat{\Delta}\left(\bigcup_i A_i,x\right),a\right) \\ & = &#10;\hat{\Delta}\left(\bigcup_i\hat{\Delta}\left(A_i, x\right),a\right) \\ & = &#10;\bigcup_i \hat{\Delta}\left(\hat{\Delta}\left(A_i , x\right), a\right) \\ & = &#10;\bigcup_i\hat{\Delta}\left(A_i, xa\right)&#10;\end{align*}&#10;"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><munder><mo>⋃</mo><mi>i</mi></munder><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><munder><mo>⋃</mo><mi>i</mi></munder><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><munder><mo>⋃</mo><mi>i</mi></munder><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mi>i</mi></munder><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mi>i</mi></munder><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex"> \begin{align*} \hat{\Delta}\left(\bigcup_i A_i, xa\right) &amp; =  \hat{\Delta}\left(\hat{\Delta}\left(\bigcup_i A_i,x\right),a\right) \ &amp; =  \hat{\Delta}\left(\bigcup_i\hat{\Delta}\left(A_i, x\right),a\right) \ &amp; =  \bigcup_i \hat{\Delta}\left(\hat{\Delta}\left(A_i , x\right), a\right) \ &amp; =  \bigcup_i\hat{\Delta}\left(A_i, xa\right) \end{align*} </annotation></semantics></math></span></data></p>
<p>Now the following two automata can be shown to accept the same set.</p>
<p><data class="katex-src" value="\left(Q, \Sigma, \Delta, S, F\right) = \left(2^Q, \Sigma, \hat{\Delta}, S, &#10;\{ A | A \subseteq Q, A \cap F ≠ \phi\} \right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><msup><mn>2</mn><mi>Q</mi></msup><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo>⊆</mo><mi>Q</mi><mo separator="true">,</mo><mi>A</mi><mo>∩</mo><mi>F</mi><mo mathvariant="normal">≠</mo><mi>ϕ</mi><mo stretchy="false">}</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(Q, \Sigma, \Delta, S, F\right) = \left(2^Q, \Sigma, \hat{\Delta}, S,  { A | A \subseteq Q, A \cap F ≠ \phi} \right)</annotation></semantics></math></span></data></p>
<p>To create a minimal DFA from an NFA, check the decision tree for the NFA and
do a BFS, stopping when you don’t get any new states.</p>
<h4 id="ϵepsilon-transition"><a class="header" href="#ϵepsilon-transition"><data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> transition</a></h4>
<p>This has an <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> slip that allows the state to transition without
reading any input symbol.</p>
<blockquote>
<p>Proof that <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> transition NFA’s have an equivalent NFA with just one
start state and no <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> transitions.</p>
</blockquote>
<p><strong>Defn:</strong> <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> closure: The set of all states that a state can reach on
an <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> transition.</p>
<p>Define a new transition function such that the states attained by the state
with <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> transitions further take one symbol.</p>
<p>For an <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> NFA to be converted to a regular NFA, we define</p>
<p><data class="katex-src" value="\begin{align*}&#10;\Delta'\left(q,\sigma\right) = \bigcup_{q'\in \epsilon(q)}&#10;\Delta\left(q', \sigma\right)&#10;\end{align*}&#10;"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi mathvariant="normal">Δ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>σ</mi><mo fence="true">)</mo></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi>ϵ</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow></munder><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>σ</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*} \Delta'\left(q,\sigma\right) = \bigcup_{q'\in \epsilon(q)} \Delta\left(q', \sigma\right) \end{align*} </annotation></semantics></math></span></data></p>
<p>where <data class="katex-src" value="\epsilon(q)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\epsilon(q)</annotation></semantics></math></span></data> is the <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> closure of q.</p>
<p>The final states</p>
<p><data class="katex-src" value="&#10;F' = \{q | \epsilon(q)\cap F \neq \phi\}&#10;"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mo stretchy="false">{</mo><mi>q</mi><mi mathvariant="normal">∣</mi><mi>ϵ</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>F</mi><mo mathvariant="normal">≠</mo><mi>ϕ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex"> F' = {q | \epsilon(q)\cap F \neq \phi} </annotation></semantics></math></span></data></p>
<p>Everything else remains the same.</p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<ul>
<li><data class="katex-src" value="a"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></data> for each <data class="katex-src" value="a \in \Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">a \in \Sigma</annotation></semantics></math></span></data>, matched by <data class="katex-src" value="a"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></data> only.</li>
<li><data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data>, matched by the empty string.</li>
<li><data class="katex-src" value="\phi"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span></data>, matched by nothing.</li>
<li>#, matched by any symbol in <data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="@"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">@</mi></mrow><annotation encoding="application/x-tex">@</annotation></semantics></math></span></data>, matched by anything in <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data>.</li>
</ul>
<h3 id="combining-patterns"><a class="header" href="#combining-patterns">Combining patterns</a></h3>
<ul>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha + \beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>+</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha + \beta</annotation></semantics></math></span></data> if <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches either of those.</li>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha\cap\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∩</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha\cap\beta</annotation></semantics></math></span></data> if <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches both of them.</li>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha\beta</annotation></semantics></math></span></data> if <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span></data> followed by <data class="katex-src" value="\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="~\alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>α</mi></mrow><annotation encoding="application/x-tex">~\alpha</annotation></semantics></math></span></data> if it doesn’t match <data class="katex-src" value="\alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\alpha^*</annotation></semantics></math></span></data> and <data class="katex-src" value="\alpha^+"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\alpha^+</annotation></semantics></math></span></data> the same way as regex.</li>
</ul>
<p>NOTE:<br>
<data class="katex-src" value="\left(0 + 1\right)^* "><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mrow><mo fence="true">(</mo><mn>0</mn><mo>+</mo><mn>1</mn><mo fence="true">)</mo></mrow><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\left(0 + 1\right)^* </annotation></semantics></math></span></data> accepts 010101<br>
<data class="katex-src" value=" 0^* + 1^* "><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>0</mn><mo>∗</mo></msup><mo>+</mo><msup><mn>1</mn><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex"> 0^* + 1^* </annotation></semantics></math></span></data> accepts 000000 or 111111 but only strings of one symbol</p>
<p>For any pattern <data class="katex-src" value="R"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span></data>, we define <data class="katex-src" value="L(R)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(R)</annotation></semantics></math></span></data> to be the language that matches the
pattern <data class="katex-src" value="R"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span></data>.</p>
<p>Any regular language can have countably infinite representations in form of
patterns.</p>
<p><strong>Theorem</strong>: If <data class="katex-src" value="R"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span></data> is a regular expression, then <data class="katex-src" value="L(R)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(R)</annotation></semantics></math></span></data> is regular.</p>
<p>Proof: Check for each possible case and all of them can be decomposed into a
combination of the above situations.</p>
<blockquote>
<p>It is always possible to remove the complement in a regular expression.</p>
</blockquote>
<h3 id="dfas-to-regex"><a class="header" href="#dfas-to-regex">DFAs to Regex</a></h3>
<ul>
<li>State elimination
<ul>
<li>Keep remaining states</li>
<li>Replace transitions with transitions labelled as regex.</li>
<li>while true</li>
</ul>
</li>
</ul>
<h2 id="class"><a class="header" href="#class">Class</a></h2>
<p><strong>Theorem:</strong> Set of all C Programs is countable.</p>
<p>Proof: <br></p>
<p>Represent the ascii source code in binary. Then it will be a subset of
<data class="katex-src" value="\{0,1\}^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">}</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">{0,1}^*</annotation></semantics></math></span></data> and that is bijective with the natural numbers
(<data class="katex-src" value="n(b) + 2^{|b|} -1"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mrow><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n(b) + 2^{|b|} -1</annotation></semantics></math></span></data>). It is also obviously infinite.</p>
<blockquote>
<p>Hilbert’s Entscheidungs Problem: Given a mathematical statement, is
it derivable from the axioms?</p>
</blockquote>
<p><strong>Defn:</strong> A language <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data> over an alphabet <data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data> is a subset of <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data>.</p>
<p><strong>Theorem:</strong> The cardinality of all the languages over some alphabet is
uncountably infinite, i.e., <data class="katex-src" value="\left|\mathcal{P}\left(L\right)\right| >&#10;\left|\mathbb{N}\right|"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><mi mathvariant="script">P</mi><mrow><mo fence="true">(</mo><mi>L</mi><mo fence="true">)</mo></mrow><mo fence="true">∣</mo></mrow><mo>&gt;</mo><mrow><mo fence="true">∣</mo><mi mathvariant="double-struck">N</mi><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">\left|\mathcal{P}\left(L\right)\right| &gt; \left|\mathbb{N}\right|</annotation></semantics></math></span></data>.</p>
<p>Proof:</p>
<p>Cantor’s argument:</p>
<p>Set of all languages = <data class="katex-src" value="\mathcal{P}\left(\{0,1\}^*\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi><mrow><mo fence="true">(</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">}</mo><mo>∗</mo></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{P}\left({0,1}^*\right)</annotation></semantics></math></span></data></p>
<div class="table-wrapper"><table><thead><tr><th>input</th><th><data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data></th><th>0</th><th>1</th><th>00</th></tr></thead><tbody>
<tr><td>f(<data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data>)</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>f(0)</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>f(1)</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>f(01)</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>
</tbody></table>
</div>
<p>The entries in the table tell whether that particular element is present in the
subset is obtained from the result or not.</p>
<p>Take the diagonal and bit flip all bits. It will differ from all the strings in
the table by atleast one bit.</p>
<p>Go to <a href="./cs2200.html#cs2200">top</a> till
<a href="./cs2200.html#deterministic-finite-automata">Deterministic Finite Automata</a>
along with a few examples of languages based on the problem.</p>
<h3 id="limits-of-dfas"><a class="header" href="#limits-of-dfas">Limits of DFAs</a></h3>
<ul>
<li>DFAs have finite memory.</li>
<li>They can also only read one symbol at a time from left to right.</li>
</ul>
<p>For instance, there is no way of constructing a DFA that can accept <data class="katex-src" value="L =&#10;\{0^n1^n | n \in \mathbb{N}\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false">{</mo><msup><mn>0</mn><mi>n</mi></msup><msup><mn>1</mn><mi>n</mi></msup><mi mathvariant="normal">∣</mi><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L = {0^n1^n | n \in \mathbb{N}}</annotation></semantics></math></span></data>.</p>
<p>Similarly, there is no DFA that can accept the language <data class="katex-src" value="L = \{0^{2^n}| n&#10;\in \mathbb{N}\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false">{</mo><msup><mn>0</mn><msup><mn>2</mn><mi>n</mi></msup></msup><mi mathvariant="normal">∣</mi><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L = {0^{2^n}| n \in \mathbb{N}}</annotation></semantics></math></span></data></p>
<blockquote>
<p>Important Proof</p>
</blockquote>
<p>If <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data> is regular, where <data class="katex-src" value="L = \{ww | w \in \Sigma^* \}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false">{</mo><mi>w</mi><mi>w</mi><mi mathvariant="normal">∣</mi><mi>w</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L = {ww | w \in \Sigma^* }</annotation></semantics></math></span></data>, then <data class="katex-src" value="\sqrt{L}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>L</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt{L}</annotation></semantics></math></span></data> is
also regular.</p>
<p>Proof:</p>
<p>Let the DFA be <data class="katex-src" value="\left(Q, \Sigma, \delta, q_0, F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(Q, \Sigma, \delta, q_0, F\right)</annotation></semantics></math></span></data>. We define the
NFA as follows:</p>
<p><data class="katex-src" value="N = \left(Q \times Q \times Q, \Sigma, \Delta, A, f\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>N</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo>×</mo><mi>Q</mi><mo>×</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo separator="true">,</mo><mi>A</mi><mo separator="true">,</mo><mi>f</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">N = \left(Q \times Q \times Q, \Sigma, \Delta, A, f\right)</annotation></semantics></math></span></data></p>
<p>where</p>
<p><data class="katex-src" value="\begin{align}&#10;A &= \bigcup_{i\in Q} {\left(i, q_0, i\right)}&#10;\\&#10;f &= \bigcup_{i \in Q\atop z\in F} {\left(i, i, z\right)}&#10;\\&#10;\Delta\left(\left(i, \alpha, \beta\right), a_0\right) &= \left(i, &#10;\delta\left(\alpha, a_0\right), \delta\left(\beta, a_0\right)\right)&#10;\end{align}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>A</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><mi>i</mi><mo>∈</mo><mi>Q</mi></mrow></munder><mrow><mo fence="true">(</mo><mi>i</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>i</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>f</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mfrac linethickness="0px"><mrow><mi>i</mi><mo>∈</mo><mi>Q</mi></mrow><mrow><mi>z</mi><mo>∈</mo><mi>F</mi></mrow></mfrac></munder><mrow><mo fence="true">(</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>z</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><mrow><mo fence="true">(</mo><mi>i</mi><mo separator="true">,</mo><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mi>i</mi><mo separator="true">,</mo><mi>δ</mi><mrow><mo fence="true">(</mo><mi>α</mi><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>δ</mi><mrow><mo fence="true">(</mo><mi>β</mi><mo separator="true">,</mo><msub><mi>a</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} A &amp;= \bigcup_{i\in Q} {\left(i, q_0, i\right)} \ f &amp;= \bigcup_{i \in Q\atop z\in F} {\left(i, i, z\right)} \ \Delta\left(\left(i, \alpha, \beta\right), a_0\right) &amp;= \left(i,  \delta\left(\alpha, a_0\right), \delta\left(\beta, a_0\right)\right) \end{align}</annotation></semantics></math></span></data></p>
<h3 id="pumping-lemma"><a class="header" href="#pumping-lemma">Pumping Lemma</a></h3>
<p>Let <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data> be a regular language. <data class="katex-src" value="\exists k > 0"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>k</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\exists k &gt; 0</annotation></semantics></math></span></data>, s.t. <data class="katex-src" value="\forall x,y,z"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi></mrow><annotation encoding="application/x-tex">\forall x,y,z</annotation></semantics></math></span></data> s.t.
<data class="katex-src" value="xyz \in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">xyz \in L</annotation></semantics></math></span></data> and <data class="katex-src" value="|y| > k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">|y| &gt; k</annotation></semantics></math></span></data>, <data class="katex-src" value="\exists u,v,w"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>u</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi>w</mi></mrow><annotation encoding="application/x-tex">\exists u,v,w</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="y = uvw, v\ne \epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>u</mi><mi>v</mi><mi>w</mi><mo separator="true">,</mo><mi>v</mi><mo mathvariant="normal">≠</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">y = uvw, v\ne \epsilon</annotation></semantics></math></span></data>
s.t. <data class="katex-src" value="\forall i \geq 0, xuv^iwz \in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo>≥</mo><mn>0</mn><mo separator="true">,</mo><mi>x</mi><mi>u</mi><msup><mi>v</mi><mi>i</mi></msup><mi>w</mi><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\forall i \geq 0, xuv^iwz \in L</annotation></semantics></math></span></data>.</p>
<p>Proof: <data class="katex-src" value="\exists M = \left(Q, \Sigma, \delta, q_0, F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\exists M = \left(Q, \Sigma, \delta, q_0, F\right)</annotation></semantics></math></span></data> s.t.
<data class="katex-src" value="L\left(M\right) = L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mrow><mo fence="true">(</mo><mi>M</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L\left(M\right) = L</annotation></semantics></math></span></data>.</p>
<p>Set <data class="katex-src" value="k = |Q|"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mi mathvariant="normal">∣</mi><mi>Q</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">k = |Q|</annotation></semantics></math></span></data></p>
<p>Let <data class="katex-src" value="x,y,z \in \Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x,y,z \in \Sigma^*</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="|y| > k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>y</mi><mi mathvariant="normal">∣</mi><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">|y| &gt; k</annotation></semantics></math></span></data> &amp; <data class="katex-src" value="xyz \in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>y</mi><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">xyz \in L</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="\begin{align*}&#10;\hat{\delta}\left(q_0, x\right) &= q &&#10;\hat{\delta}\left(q, y\right) &= q' &&#10;\hat{\delta}\left(q', z\right) & \in F &&#10;\end{align*}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left right left right left right" columnspacing="0em 1em 0em 1em 0em 1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>q</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>y</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>z</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>∈</mo><mi>F</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*} \hat{\delta}\left(q_0, x\right) &amp;= q &amp; \hat{\delta}\left(q, y\right) &amp;= q' &amp; \hat{\delta}\left(q', z\right) &amp; \in F &amp; \end{align*}</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="y = y_1y_2...y_r, r> k"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><msub><mi>y</mi><mn>1</mn></msub><msub><mi>y</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>r</mi></msub><mo separator="true">,</mo><mi>r</mi><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">y = y_1y_2…y_r, r&gt; k</annotation></semantics></math></span></data>. We define <data class="katex-src" value="q_i = \hat{\delta}&#10;\left(q, y_1y_2...y_i\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mi>i</mi></msub><mo>=</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><msub><mi>y</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>i</mi></msub><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">q_i = \hat{\delta} \left(q, y_1y_2…y_i\right)</annotation></semantics></math></span></data></p>
<p>Consider the sequence <data class="katex-src" value="q_1q_2q_3...q_r"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>1</mn></msub><msub><mi>q</mi><mn>2</mn></msub><msub><mi>q</mi><mn>3</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>q</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">q_1q_2q_3…q_r</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="\implies \exists s, t"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi mathvariant="normal">∃</mi><mi>s</mi><mo separator="true">,</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">\implies \exists s, t</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="q_s = q_t"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mi>s</mi></msub><mo>=</mo><msub><mi>q</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">q_s = q_t</annotation></semantics></math></span></data> in the sequence (by PHP).</p>
<p>Define</p>
<p><data class="katex-src" value="u = y_1y_2...y_s"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>u</mi><mo>=</mo><msub><mi>y</mi><mn>1</mn></msub><msub><mi>y</mi><mn>2</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>s</mi></msub></mrow><annotation encoding="application/x-tex">u = y_1y_2…y_s</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="v = y_{s+1}y_{s+2}...y_t"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mo>=</mo><msub><mi>y</mi><mrow><mi>s</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>y</mi><mrow><mi>s</mi><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">v = y_{s+1}y_{s+2}…y_t</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="w = y_{t+1}y_{t+2}...y_r"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo>=</mo><msub><mi>y</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><msub><mi>y</mi><mrow><mi>t</mi><mo>+</mo><mn>2</mn></mrow></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>y</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">w = y_{t+1}y_{t+2}…y_r</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="\begin{align}&#10;\hat{\delta}\left(q_0, x\right)  &= q &#10;\\&#10;\hat{\delta}\left(q, u\right)  &= q_s &#10;\\&#10;\hat{\delta}\left(q_s, v\right)  &= q_s \implies \hat{\delta}&#10;\left(q_s, v^i\right) = q_s &#10;\\&#10;\hat{\delta}\left(q_s, wz\right)  &\in F&#10;\end{align}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>q</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>u</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>q</mi><mi>s</mi></msub></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mi>s</mi></msub><mo separator="true">,</mo><mi>v</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><msub><mi>q</mi><mi>s</mi></msub><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mi>s</mi></msub><mo separator="true">,</mo><msup><mi>v</mi><mi>i</mi></msup><mo fence="true">)</mo></mrow><mo>=</mo><msub><mi>q</mi><mi>s</mi></msub></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mi>s</mi></msub><mo separator="true">,</mo><mi>w</mi><mi>z</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>∈</mo><mi>F</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} \hat{\delta}\left(q_0, x\right)  &amp;= q  \ \hat{\delta}\left(q, u\right)  &amp;= q_s  \ \hat{\delta}\left(q_s, v\right)  &amp;= q_s \implies \hat{\delta} \left(q_s, v^i\right) = q_s  \ \hat{\delta}\left(q_s, wz\right)  &amp;\in F \end{align}</annotation></semantics></math></span></data></p>
<p>An analogy with a 2 player game:</p>
<p>Prover: I’ll give you a number k</p>
<p>Spoiler: I’ll find x, y, z such that the concatenation is in the language with
length of y &gt; k</p>
<p>Prover: I’ll split y into u, v, w where v is non-empty.</p>
<p>Spoiler: I’ll find an i &gt; 0 such that the pumping lemma string doesn’t belong
in the DFA. If I do that, I’ll win. And L will not be regular.</p>
<h3 id="an-alternate-way-to-prove-that-a-language-is-not-regular"><a class="header" href="#an-alternate-way-to-prove-that-a-language-is-not-regular">An alternate way to prove that a language is not regular.</a></h3>
<p>Suppose you take a DFA for the language. We take an infinite set of strings
such that all of them go to a different state. Then it’s obvious that the
DFA cannot be finite and hence, it is not a DFA.</p>
<p>Example:</p>
<p><data class="katex-src" value="\begin{align}&#10;L &= \{0^n1^n | n \ge 0\}&#10;\\&#10;M &= \left(Q, \Sigma, \delta, q_0, F\right)&#10;\\&#10;L &= L\left(M\right)&#10;\\&#10;W &= \{0^i | i \ge 0\}&#10;\end{align}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>L</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">{</mo><msup><mn>0</mn><mi>n</mi></msup><msup><mn>1</mn><mi>n</mi></msup><mi mathvariant="normal">∣</mi><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">}</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>M</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>L</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>L</mi><mrow><mo fence="true">(</mo><mi>M</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mi>W</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mo stretchy="false">{</mo><msup><mn>0</mn><mi>i</mi></msup><mi mathvariant="normal">∣</mi><mi>i</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">}</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} L &amp;= {0^n1^n | n \ge 0} \ M &amp;= \left(Q, \Sigma, \delta, q_0, F\right) \ L &amp;= L\left(M\right) \ W &amp;= {0^i | i \ge 0} \end{align}</annotation></semantics></math></span></data></p>
<p>We claim that any two strings in <data class="katex-src" value="W"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span></data> reach a different state.</p>
<p><strong>Proof:</strong></p>
<p><data class="katex-src" value="\begin{align}&#10;\hat{\delta}\left(q_0, 0^i\right) &\ne \hat{\delta}\left(q_0, 0^j\right) &#10;\forall i \ne j&#10;\\&#10;\hat{\delta}\left(q_0, 0^i1^i\right) &= \hat{\delta}\left(\hat{\delta}&#10;\left(q_0, 0 ^i\right), 1^i\right) &#10;\\&#10;&\ne \hat{\delta}\left(\hat{\delta}\left(q_0, 0^j\right), 1^i\right)&#10;\end{align}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><msup><mn>0</mn><mi>i</mi></msup><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo mathvariant="normal">≠</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><msup><mn>0</mn><mi>j</mi></msup><mo fence="true">)</mo></mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><msup><mn>0</mn><mi>i</mi></msup><msup><mn>1</mn><mi>i</mi></msup><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><msup><mn>0</mn><mi>i</mi></msup><mo fence="true">)</mo></mrow><mo separator="true">,</mo><msup><mn>1</mn><mi>i</mi></msup><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo mathvariant="normal">≠</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><msup><mn>0</mn><mi>j</mi></msup><mo fence="true">)</mo></mrow><mo separator="true">,</mo><msup><mn>1</mn><mi>i</mi></msup><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} \hat{\delta}\left(q_0, 0^i\right) &amp;\ne \hat{\delta}\left(q_0, 0^j\right)  \forall i \ne j \ \hat{\delta}\left(q_0, 0^i1^i\right) &amp;= \hat{\delta}\left(\hat{\delta} \left(q_0, 0 ^i\right), 1^i\right)  \ &amp;\ne \hat{\delta}\left(\hat{\delta}\left(q_0, 0^j\right), 1^i\right) \end{align}</annotation></semantics></math></span></data></p>
<p>If this wasn’t true then both the strings will be accepted, which is
impossible according to the language.</p>
<h3 id="distinguishability"><a class="header" href="#distinguishability">Distinguishability</a></h3>
<p><strong>Defn</strong>: Let <data class="katex-src" value="L \subseteq \Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^<em></annotation></semantics></math></span></data> be a language. Two strings <data class="katex-src" value="x,y \in&#10;\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x,y \in \Sigma^</em></annotation></semantics></math></span></data> are said to be distinguishable by <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data> if <data class="katex-src" value="\exists z \in&#10;\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\exists z \in \Sigma^*</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="xz \in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">xz \in L</annotation></semantics></math></span></data> and <data class="katex-src" value="yz \notin L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mi>z</mi><mo mathvariant="normal">∉</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">yz \notin L</annotation></semantics></math></span></data>.</p>
<p><strong>Defn</strong>: A set <data class="katex-src" value="S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span></data> is distinguishable if <data class="katex-src" value="\forall i \ne j \in S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\forall i \ne j \in S</annotation></semantics></math></span></data> and <data class="katex-src" value="i"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span></data>
and <data class="katex-src" value="j"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span></data> are distinguishable.</p>
<p><strong>Theorem</strong>: Let <data class="katex-src" value="L \subseteq \Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math></span></data> be a regular language and <data class="katex-src" value="S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span></data> be
a distinguishable set. For any DFA accepting <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data>, <data class="katex-src" value="\left|Q\right| \ge&#10;\left|S\right|"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><mi>Q</mi><mo fence="true">∣</mo></mrow><mo>≥</mo><mrow><mo fence="true">∣</mo><mi>S</mi><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">\left|Q\right| \ge \left|S\right|</annotation></semantics></math></span></data>.</p>
<h3 id="myhill-nerode-relations"><a class="header" href="#myhill-nerode-relations">Myhill-Nerode Relations</a></h3>
<p>An equivalence relation <data class="katex-src" value="\equiv"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span></data> over a language <data class="katex-src" value="L \subseteq \Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>⊆</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">L \subseteq \Sigma^*</annotation></semantics></math></span></data> is
said to be a <em>Myhill-Nerode relation</em> if</p>
<ol>
<li><data class="katex-src" value="\equiv"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span></data> is a right congruence, i.e., if <data class="katex-src" value="x \equiv y"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x \equiv y</annotation></semantics></math></span></data>, then <data class="katex-src" value="x\sigma&#10;   \equiv y\sigma \forall \sigma \in \Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mi>σ</mi><mo>≡</mo><mi>y</mi><mi>σ</mi><mi mathvariant="normal">∀</mi><mi>σ</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">x\sigma    \equiv y\sigma \forall \sigma \in \Sigma</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="\equiv"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span></data> is a refinement of <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data>, i.e., if <data class="katex-src" value="x\equiv y"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x\equiv y</annotation></semantics></math></span></data> then <data class="katex-src" value="x\in L&#10;   \iff y\in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>L</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>y</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">x\in L    \iff y\in L</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="\equiv"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span></data> is of finite index.</li>
</ol>
<p>If <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data> is regular and <data class="katex-src" value="M = \left(Q,\Sigma, \delta, q_0, F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M = \left(Q,\Sigma, \delta, q_0, F\right)</annotation></semantics></math></span></data>
accepts M, then <data class="katex-src" value="\equiv_M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>≡</mo><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">\equiv_M</annotation></semantics></math></span></data> is a <em>Myhill-Nerode</em> relation.
It is trivial to see why this is the case.</p>
<p>We define <data class="katex-src" value="\equiv_M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>≡</mo><mi>M</mi></msub></mrow><annotation encoding="application/x-tex">\equiv_M</annotation></semantics></math></span></data> to be the equivalence relation gotten when any two
strings end up in the same equivalence class in the language accepted by
<data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> i.e. <data class="katex-src" value="\hat{\delta}\left(q_0, x\right) = \hat{\delta}\left(q_0, y\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>=</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>y</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(q_0, x\right) = \hat{\delta}\left(q_0, y\right)</annotation></semantics></math></span></data>.</p>
<p>We define <data class="katex-src" value="\equiv_L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>≡</mo><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">\equiv_L</annotation></semantics></math></span></data> to be the equivalence relation gotten when any two
strings <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> and <data class="katex-src" value="y"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span></data> s.t. <data class="katex-src" value="\forall z \in \Sigma^*, xz \in L&#10;\Longleftrightarrow yz \in L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo separator="true">,</mo><mi>x</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mo>⟺</mo><mi>y</mi><mi>z</mi><mo>∈</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">\forall z \in \Sigma^*, xz \in L \Longleftrightarrow yz \in L</annotation></semantics></math></span></data>.</p>
<p><strong>Theorem</strong>: Let <data class="katex-src" value="\equiv"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo></mrow><annotation encoding="application/x-tex">\equiv</annotation></semantics></math></span></data> be an MH relation over <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data>.</p>
<p>Then <data class="katex-src" value="\equiv \subseteq \equiv_L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≡</mo><mo>⊆</mo><msub><mo>≡</mo><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">\equiv \subseteq \equiv_L</annotation></semantics></math></span></data>.</p>
<p>Proof:</p>
<p><data class="katex-src" value="\begin{align}&#10;&\forall x,y, x\equiv y &#10;\\&#10;&\forall \sigma \in \Sigma, x\sigma \equiv y\sigma &#10;\\&#10;&\forall z \in \Sigma^* , \implies \left(xz \in L \iff yz\in L\right)&#10;\\&#10;&\implies x\equiv_L y&#10;\end{align}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>x</mi><mo>≡</mo><mi>y</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi mathvariant="normal">∀</mi><mi>σ</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>x</mi><mi>σ</mi><mo>≡</mo><mi>y</mi><mi>σ</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mi mathvariant="normal">∀</mi><mi>z</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo separator="true">,</mo><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mrow><mo fence="true">(</mo><mi>x</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mtext>  </mtext><mo>⟺</mo><mtext>  </mtext><mi>y</mi><mi>z</mi><mo>∈</mo><mi>L</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mi>x</mi><msub><mo>≡</mo><mi>L</mi></msub><mi>y</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} &amp;\forall x,y, x\equiv y  \ &amp;\forall \sigma \in \Sigma, x\sigma \equiv y\sigma  \ &amp;\forall z \in \Sigma^* , \implies \left(xz \in L \iff yz\in L\right) \ &amp;\implies x\equiv_L y \end{align}</annotation></semantics></math></span></data></p>
<h3 id="minimizing-dfas-and-isomorphism"><a class="header" href="#minimizing-dfas-and-isomorphism">Minimizing DFAs and Isomorphism</a></h3>
<p>Let <data class="katex-src" value="M = \left(Q,\Sigma, \delta, s, F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M = \left(Q,\Sigma, \delta, s, F\right)</annotation></semantics></math></span></data> and <data class="katex-src" value="M' = \left(Q', \Sigma,&#10;\delta', s', F' \right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mrow><mo fence="true">(</mo><msup><mi>Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><msup><mi>δ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M' = \left(Q', \Sigma, \delta', s', F' \right)</annotation></semantics></math></span></data></p>
<p>Let <data class="katex-src" value="f: Q\rightarrow Q'"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>Q</mi><mo>→</mo><msup><mi>Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">f: Q\rightarrow Q'</annotation></semantics></math></span></data> be a bijection such that the following hold:</p>
<ol>
<li><data class="katex-src" value="s' = f(s)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>s</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">s' = f(s)</annotation></semantics></math></span></data></li>
<li><data class="katex-src" value="q\in F \Longleftrightarrow f(q) \in F'"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>∈</mo><mi>F</mi><mo>⟺</mo><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo>∈</mo><msup><mi>F</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">q\in F \Longleftrightarrow f(q) \in F'</annotation></semantics></math></span></data></li>
<li><data class="katex-src" value="f(\delta(q,\sigma)) = \delta'(f(q), \sigma) \forall q \in Q, \sigma \in&#10;   \Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><msup><mi>δ</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>q</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∀</mi><mi>q</mi><mo>∈</mo><mi>Q</mi><mo separator="true">,</mo><mi>σ</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">f(\delta(q,\sigma)) = \delta'(f(q), \sigma) \forall q \in Q, \sigma \in    \Sigma</annotation></semantics></math></span></data></li>
</ol>
<p><strong>Theorem</strong>: If <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> and <data class="katex-src" value="M'"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>M</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">M'</annotation></semantics></math></span></data> are two minimal automatas then they are isomorphic.</p>
<p>Proof:</p>
<p>We define the function <data class="katex-src" value="f^{-1}: Q' \rightarrow Q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>:</mo><msup><mi>Q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">f^{-1}: Q' \rightarrow Q</annotation></semantics></math></span></data> to be <data class="katex-src" value="\hat{\delta}(s, x)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>s</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{\delta}(s, x)</annotation></semantics></math></span></data></p>
<p><strong>Algorithm</strong> to minimize the DFA:</p>
<p>States <data class="katex-src" value="q, q' \in M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo separator="true">,</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>∈</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">q, q' \in M</annotation></semantics></math></span></data> are equivalent if <data class="katex-src" value="\forall x\in \Sigma^*, \hat{\delta}&#10;(q,x) \in F \Longleftrightarrow \hat{\delta}(q', x) \in F"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∀</mi><mi>x</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo separator="true">,</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>F</mi><mo>⟺</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msup><mi>q</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">\forall x\in \Sigma^*, \hat{\delta} (q,x) \in F \Longleftrightarrow \hat{\delta}(q', x) \in F</annotation></semantics></math></span></data></p>
<p>This is clearly an equivalence relation for the states.</p>
<p>Show that the Myhill-Nerode relation of the <strong>Quotient Automata</strong>
<data class="katex-src" value="M_{/\approx}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mrow><mi mathvariant="normal">/</mi><mo>≈</mo></mrow></msub></mrow><annotation encoding="application/x-tex">M_{/\approx}</annotation></semantics></math></span></data> is a superset of the other. Hence the quotient automata is the
minimal one.</p>
<p><em>Algorithm</em>:</p>
<p>Mark any two pairs of states that are clearly not equivalent (one of them is a
final state, other is not).</p>
<p>Repeat until no new pairs are marked</p>
<p>If <data class="katex-src" value="\exists \{p,q\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∃</mi><mo stretchy="false">{</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\exists {p,q}</annotation></semantics></math></span></data> s.t. for some <data class="katex-src" value="\sigma \in \Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\sigma \in \Sigma</annotation></semantics></math></span></data>, <data class="katex-src" value="\{\delta(p,\sigma),&#10;\delta(q,\sigma)\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>p</mi><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">{\delta(p,\sigma), \delta(q,\sigma)}</annotation></semantics></math></span></data> are marked then mark <data class="katex-src" value="\{p,q\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">{p,q}</annotation></semantics></math></span></data></p>
<p>Go to <a href="./cs2200.html#pattern-matching">pattern matching</a></p>
<h3 id="context-free-languages"><a class="header" href="#context-free-languages">Context free languages</a></h3>
<p>Productions: A kind of statement that telly you substitution rule.</p>
<p>Non-terminal strings are strings that can be replaced using productions.</p>
<p>Terminals are ones that can’t be further replaced.</p>
<p>Therefore, CFG is a 4 tuple that is defined using
<data class="katex-src" value="\left(N, \Sigma, P, S\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo fence="true">(</mo><mi>N</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo fence="true">)</mo></mrow><annotation encoding="application/x-tex">\left(N, \Sigma, P, S\right)</annotation></semantics></math></span></data></p>
<ul>
<li><data class="katex-src" value="N"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span></data> is the set of non-terminals (RHS in any production).</li>
<li><data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data> set of terminals</li>
<li><data class="katex-src" value="P"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span></data> set of production girls</li>
<li><data class="katex-src" value="S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span></data> start symbol</li>
</ul>
<p>E.g. <data class="katex-src" value="L = \{0^n1^n| n \ge 0\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false">{</mo><msup><mn>0</mn><mi>n</mi></msup><msup><mn>1</mn><mi>n</mi></msup><mi mathvariant="normal">∣</mi><mi>n</mi><mo>≥</mo><mn>0</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L = {0^n1^n| n \ge 0}</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="S \rightarrow 0S1 | \epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mn>0</mn><mi>S</mi><mn>1</mn><mi mathvariant="normal">∣</mi><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">S \rightarrow 0S1 | \epsilon</annotation></semantics></math></span></data></p>
<ul>
<li>A string <data class="katex-src" value="\beta \in (N \bigcup \Sigma^* )"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>N</mi><mo>⋃</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\beta \in (N \bigcup \Sigma^* )</annotation></semantics></math></span></data> is <em>derivable</em> from <data class="katex-src" value="\alpha \in&#10;  (N\bigcup \Sigma)^* "><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>N</mi><mo>⋃</mo><mi mathvariant="normal">Σ</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\alpha \in   (N\bigcup \Sigma)^* </annotation></semantics></math></span></data> if there is a production rule to substitute a
non-terminal in <data class="katex-src" value="\alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span></data> and get <data class="katex-src" value="\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span></data>.</li>
<li>A string in <data class="katex-src" value="(N\bigcup\Sigma)^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>N</mi><mo>⋃</mo><mi mathvariant="normal">Σ</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">(N\bigcup\Sigma)^*</annotation></semantics></math></span></data> is known as a <em>sentential form</em> if it is
derivable from S.</li>
<li>A string in <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data> is a <strong>sentence</strong> if it is derivable from <data class="katex-src" value="S"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span></data>.</li>
</ul>
<!---TODO: fill examples--->
<p><strong>Theorem:</strong> For a regular language <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data>, there exists grammar <data class="katex-src" value="G"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span></data> s.t.
<data class="katex-src" value="L = L(G)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L = L(G)</annotation></semantics></math></span></data></p>
<p>Proof:</p>
<p><data class="katex-src" value="\begin{align}&#10;\exists M = \left(Q,\Sigma, \delta, q_0, F\right) \\&#10;L(M) = L \\&#10;N = \{S_i | q_i \in Q\} \\&#10;S_i \rightarrow \sigma S_j \forall \delta(q_i, \sigma) = q_j \\&#10;q_i \in F \implies S_i \rightarrow \epsilon \\&#10;\end{align}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right" columnspacing=""><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi mathvariant="normal">∃</mi><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mi>N</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>S</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>q</mi><mi>i</mi></msub><mo>∈</mo><mi>Q</mi><mo stretchy="false">}</mo></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>→</mo><mi>σ</mi><msub><mi>S</mi><mi>j</mi></msub><mi mathvariant="normal">∀</mi><mi>δ</mi><mo stretchy="false">(</mo><msub><mi>q</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>σ</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>q</mi><mi>j</mi></msub></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr><mtr><mtd class ="mtr-glue"></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msub><mi>q</mi><mi>i</mi></msub><mo>∈</mo><mi>F</mi><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><msub><mi>S</mi><mi>i</mi></msub><mo>→</mo><mi>ϵ</mi></mrow></mstyle></mtd><mtd class ="mtr-glue"></mtd><mtd class ="mml-eqn-num"></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} \exists M = \left(Q,\Sigma, \delta, q_0, F\right) \ L(M) = L \ N = {S_i | q_i \in Q} \ S_i \rightarrow \sigma S_j \forall \delta(q_i, \sigma) = q_j \ q_i \in F \implies S_i \rightarrow \epsilon \ \end{align}</annotation></semantics></math></span></data></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../notes/cp_qs_reading.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../notes/cs2600.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../notes/cp_qs_reading.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../notes/cs2600.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
