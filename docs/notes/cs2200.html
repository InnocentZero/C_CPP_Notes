<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>./notes/cs2200.md - Notes</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href=".././src/notes/custom.css">
        <link rel="stylesheet" href=".././src/notes/katex.min.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../notes/algorithms.html"><strong aria-hidden="true">1.</strong> ./notes/algorithms.md</a></li><li class="chapter-item "><a href="../notes/arp.html"><strong aria-hidden="true">2.</strong> ./notes/arp.md</a></li><li class="chapter-item "><a href="../notes/asm.html"><strong aria-hidden="true">3.</strong> ./notes/asm.md</a></li><li class="chapter-item "><a href="../notes/basic_preproc.html"><strong aria-hidden="true">4.</strong> ./notes/basic_preproc.md</a></li><li class="chapter-item "><a href="../notes/boost_asio.html"><strong aria-hidden="true">5.</strong> ./notes/boost_asio.md</a></li><li class="chapter-item "><a href="../notes/c_codes.html"><strong aria-hidden="true">6.</strong> ./notes/c_codes.md</a></li><li class="chapter-item "><a href="../notes/classes.html"><strong aria-hidden="true">7.</strong> ./notes/classes.md</a></li><li class="chapter-item "><a href="../notes/cmake.html"><strong aria-hidden="true">8.</strong> ./notes/cmake.md</a></li><li class="chapter-item "><a href="../notes/C_notes.html"><strong aria-hidden="true">9.</strong> ./notes/C_notes.md</a></li><li class="chapter-item "><a href="../notes/compilers.html"><strong aria-hidden="true">10.</strong> ./notes/compilers.md</a></li><li class="chapter-item "><a href="../notes/concurrency.html"><strong aria-hidden="true">11.</strong> ./notes/concurrency.md</a></li><li class="chapter-item "><a href="../notes/cont_struct.html"><strong aria-hidden="true">12.</strong> ./notes/cont_struct.md</a></li><li class="chapter-item "><a href="../notes/cp_codes.html"><strong aria-hidden="true">13.</strong> ./notes/cp_codes.md</a></li><li class="chapter-item "><a href="../notes/cpp_guidelines.html"><strong aria-hidden="true">14.</strong> ./notes/cpp_guidelines.md</a></li><li class="chapter-item "><a href="../notes/cpp.html"><strong aria-hidden="true">15.</strong> ./notes/cpp.md</a></li><li class="chapter-item "><a href="../notes/cp_qs_models.html"><strong aria-hidden="true">16.</strong> ./notes/cp_qs_models.md</a></li><li class="chapter-item "><a href="../notes/cp_qs_reading.html"><strong aria-hidden="true">17.</strong> ./notes/cp_qs_reading.md</a></li><li class="chapter-item expanded "><a href="../notes/cs2200.html" class="active"><strong aria-hidden="true">18.</strong> ./notes/cs2200.md</a></li><li class="chapter-item "><a href="../notes/cs2600.html"><strong aria-hidden="true">19.</strong> ./notes/cs2600.md</a></li><li class="chapter-item "><a href="../notes/csd.html"><strong aria-hidden="true">20.</strong> ./notes/csd.md</a></li><li class="chapter-item "><a href="../notes/cv_qualifiers.html"><strong aria-hidden="true">21.</strong> ./notes/cv_qualifiers.md</a></li><li class="chapter-item "><a href="../notes/data_structures.html"><strong aria-hidden="true">22.</strong> ./notes/data_structures.md</a></li><li class="chapter-item "><a href="../notes/data_types.html"><strong aria-hidden="true">23.</strong> ./notes/data_types.md</a></li><li class="chapter-item "><a href="../notes/dhcp.html"><strong aria-hidden="true">24.</strong> ./notes/dhcp.md</a></li><li class="chapter-item "><a href="../notes/dhcpv6.html"><strong aria-hidden="true">25.</strong> ./notes/dhcpv6.md</a></li><li class="chapter-item "><a href="../notes/dns.html"><strong aria-hidden="true">26.</strong> ./notes/dns.md</a></li><li class="chapter-item "><a href="../notes/enum_classes.html"><strong aria-hidden="true">27.</strong> ./notes/enum_classes.md</a></li><li class="chapter-item "><a href="../notes/file_descriptors.html"><strong aria-hidden="true">28.</strong> ./notes/file_descriptors.md</a></li><li class="chapter-item "><a href="../notes/functions.html"><strong aria-hidden="true">29.</strong> ./notes/functions.md</a></li><li class="chapter-item "><a href="../notes/gdb.html"><strong aria-hidden="true">30.</strong> ./notes/gdb.md</a></li><li class="chapter-item "><a href="../notes/hacking_basics.html"><strong aria-hidden="true">31.</strong> ./notes/hacking_basics.md</a></li><li class="chapter-item "><a href="../notes/icmp.html"><strong aria-hidden="true">32.</strong> ./notes/icmp.md</a></li><li class="chapter-item "><a href="../notes/if_else_loops.html"><strong aria-hidden="true">33.</strong> ./notes/if_else_loops.md</a></li><li class="chapter-item "><a href="../notes/io.html"><strong aria-hidden="true">34.</strong> ./notes/io.md</a></li><li class="chapter-item "><a href="../notes/ipv4.html"><strong aria-hidden="true">35.</strong> ./notes/ipv4.md</a></li><li class="chapter-item "><a href="../notes/ipv6.html"><strong aria-hidden="true">36.</strong> ./notes/ipv6.md</a></li><li class="chapter-item "><a href="../notes/jpeg.html"><strong aria-hidden="true">37.</strong> ./notes/jpeg.md</a></li><li class="chapter-item "><a href="../notes/memory.html"><strong aria-hidden="true">38.</strong> ./notes/memory.md</a></li><li class="chapter-item "><a href="../notes/natas_levels.html"><strong aria-hidden="true">39.</strong> ./notes/natas_levels.md</a></li><li class="chapter-item "><a href="../notes/network_stack.html"><strong aria-hidden="true">40.</strong> ./notes/network_stack.md</a></li><li class="chapter-item "><a href="../notes/poe.html"><strong aria-hidden="true">41.</strong> ./notes/poe.md</a></li><li class="chapter-item "><a href="../notes/pointers.html"><strong aria-hidden="true">42.</strong> ./notes/pointers.md</a></li><li class="chapter-item "><a href="../notes/project_euler.html"><strong aria-hidden="true">43.</strong> ./notes/project_euler.md</a></li><li class="chapter-item "><a href="../notes/python.html"><strong aria-hidden="true">44.</strong> ./notes/python.md</a></li><li class="chapter-item "><a href="../notes/references.html"><strong aria-hidden="true">45.</strong> ./notes/references.md</a></li><li class="chapter-item "><a href="../notes/regex.html"><strong aria-hidden="true">46.</strong> ./notes/regex.md</a></li><li class="chapter-item "><a href="../notes/registers.html"><strong aria-hidden="true">47.</strong> ./notes/registers.md</a></li><li class="chapter-item "><a href="../notes/rust_notes.html"><strong aria-hidden="true">48.</strong> ./notes/rust_notes.md</a></li><li class="chapter-item "><a href="../notes/rvalue_refs.html"><strong aria-hidden="true">49.</strong> ./notes/rvalue_refs.md</a></li><li class="chapter-item "><a href="../notes/static_variables_and_functions.html"><strong aria-hidden="true">50.</strong> ./notes/static_variables_and_functions.md</a></li><li class="chapter-item "><a href="../notes/std_forward.html"><strong aria-hidden="true">51.</strong> ./notes/std_forward.md</a></li><li class="chapter-item "><a href="../notes/strings_arrays.html"><strong aria-hidden="true">52.</strong> ./notes/strings_arrays.md</a></li><li class="chapter-item "><a href="../notes/tcp.html"><strong aria-hidden="true">53.</strong> ./notes/tcp.md</a></li><li class="chapter-item "><a href="../notes/traceroute.html"><strong aria-hidden="true">54.</strong> ./notes/traceroute.md</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Notes</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cs2200"><a class="header" href="#cs2200">cs2200</a></h1>
<p>Types of grammar:</p>
<ol>
<li>Right linear</li>
<li>Context free</li>
<li>unrestricted</li>
</ol>
<p>Types of machine models:</p>
<ol>
<li>finite memory: finite automata, regex</li>
<li>finite memory with stack: pushdown automata</li>
<li>unrestricted: turing machines, post systems, λ calculus etc.</li>
</ol>
<p>There is a one to one correspondence for the numberings above.</p>
<blockquote>
<p>Gödel’s incompleteness theorem: No matter how strong a deductive system is, there are always statements that are true but unprovable.</p>
</blockquote>
<h2 id="strings-and-sets"><a class="header" href="#strings-and-sets">Strings and Sets</a></h2>
<blockquote>
<p><em>Decision problem</em> is a function that has a one bit output: true or false, 1 or 0.</p>
</blockquote>
<p>To completely specify a decision problem, specify a set of possible inputs and the subset for which the output is true.</p>
<p>Encoding the input of a decision problem as a fixed finite length string is possible over some fixed finite alphabet.</p>
<blockquote>
<p>A <strong>finite alphabet</strong> is any finite set. A finite length string is a sequence of the elements.</p>
</blockquote>
<p>Set ops for two sets:</p>
<ul>
<li>Union</li>
<li>Intersection</li>
<li>Complement over set of all strings: Basically, it depends on the <strong>set of all strings</strong> that is chosen and hence this is often written as <data class="katex-src" value="\Sigma^* - A"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo>−</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\Sigma^* - A</annotation></semantics></math></span></data> to emphasize this.</li>
<li>Concatenation of two sets: <data class="katex-src" value="AB = \{xy | x \in A; y \in B\}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>B</mi><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mi>y</mi><mi mathvariant="normal">∣</mi><mi>x</mi><mo>∈</mo><mi>A</mi><mo separator="true">;</mo><mi>y</mi><mo>∈</mo><mi>B</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">AB = {xy | x \in A; y \in B}</annotation></semantics></math></span></data>.</li>
</ul>
<p>Set ops on one set:</p>
<ul>
<li><em>asterate</em> A* of a set. <data class="katex-src" value="A^* = \bigcup_{n\geq 0}A^n"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>∗</mo></msup><mo>=</mo><msub><mo>⋃</mo><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow></msub><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">A^* = \bigcup_{n\geq 0}A^n</annotation></semantics></math></span></data></li>
<li>A<sup>+</sup> of a set. <data class="katex-src" value="A^+ = \bigcup_{n \geq 1}A^n"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo>+</mo></msup><mo>=</mo><msub><mo>⋃</mo><mrow><mi>n</mi><mo>≥</mo><mn>1</mn></mrow></msub><msup><mi>A</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">A^+ = \bigcup_{n \geq 1}A^n</annotation></semantics></math></span></data>.</li>
</ul>
<h2 id="states-and-transitions"><a class="header" href="#states-and-transitions">States and transitions</a></h2>
<p>A <strong>state</strong> of a system gives all the relevant information of a system, like a <em>snapshot</em>. <strong>Transitions</strong> are changes of states.</p>
<p>If both are finite, then the system is called a <em>finite state transition</em> system. We model them using <em>finite automata</em>.</p>
<h3 id="deterministic-finite-automata"><a class="header" href="#deterministic-finite-automata">Deterministic Finite Automata</a></h3>
<p>Formally,</p>
<p><data class="katex-src" value="M = \left(Q,\Sigma,\delta,s,F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>δ</mi><mo separator="true">,</mo><mi>s</mi><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M = \left(Q,\Sigma,\delta,s,F\right)</annotation></semantics></math></span></data></p>
<ul>
<li><em>Q</em> is the finite set of states.</li>
<li><data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data> is the finite set of the input <em>alphabet</em>.</li>
<li><data class="katex-src" value="\delta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span></data> is the transition function that takes the current state and the input <em>character</em> as the inputs and gives the next state as the output.</li>
<li><em>s</em> is the start state.</li>
<li><em>F</em> is the finite subset of <em>Q</em> that are acceptable as the final states.</li>
</ul>
<p>To extend the character input to a <em>string</em>, we define <data class="katex-src" value="\hat{\delta}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\delta}</annotation></semantics></math></span></data> inductively as follows:</p>
<ul>
<li><data class="katex-src" value="\hat{\delta}\left(q, xa\right) = \delta\left(\hat{\delta}\left(q, x\right), a\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>x</mi><mi>a</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>δ</mi><mrow><mo fence="true">(</mo><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(q, xa\right) = \delta\left(\hat{\delta}\left(q, x\right), a\right)</annotation></semantics></math></span></data></li>
<li><data class="katex-src" value="\hat{\delta}\left(q, \epsilon\right) = q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>ϵ</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(q, \epsilon\right) = q</annotation></semantics></math></span></data></li>
</ul>
<p>Where <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> is a <em>string</em>, <data class="katex-src" value="a"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></data> is a character, and <data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data> is the empty input.</p>
<p>These can also be translated to the finite state machines <a href="./csd.html#finite-state-machines">discussed here</a>.</p>
<p>A string <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> is accepted by an automation <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> if</p>
<p><data class="katex-src" value="\hat{\delta}\left(s,x\right) \in F"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi>δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>s</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>∈</mo><mi>F</mi></mrow><annotation encoding="application/x-tex">\hat{\delta}\left(s,x\right) \in F</annotation></semantics></math></span></data></p>
<p>A <em>set</em> or a <em>language</em> accepted by <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data> is the set of all strings accepted by some automata <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data>, also called <data class="katex-src" value="L(M)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(M)</annotation></semantics></math></span></data>. Any subset of <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data> is said to be regular if it is accepted by some automaton <data class="katex-src" value="M"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span></data>.</p>
<h3 id="non-deterministic-finite-automata"><a class="header" href="#non-deterministic-finite-automata">Non-deterministic Finite Automata</a></h3>
<p>A finite automata where the next state is not necessarily determined by the current state and the input symbol. It is effectively in a state of <em>guesssing</em>.</p>
<p>To show that an automata accepts a set <data class="katex-src" value="B"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span></data>, we argue that there exists a lucky sequence of guesses that lead from the start state to an accept state when the end of <data class="katex-src" value="x\in B"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">x\in B</annotation></semantics></math></span></data> is reached, but for any string outside of the set, it is impossible.</p>
<p>Formally,</p>
<p><data class="katex-src" value="M = \left(Q,\Sigma,\Delta,S,F\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>M</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">M = \left(Q,\Sigma,\Delta,S,F\right)</annotation></semantics></math></span></data></p>
<ul>
<li><em>Q</em> is the finite set of states.</li>
<li><data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data> is the finite set of the input <em>alphabet</em>.</li>
<li><data class="katex-src" value="\Delta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span></data> is the transition function that takes the current state and the input <em>character</em> as the inputs and gives the next state as the output. In this case, there are <data class="katex-src" value="2^Q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">2^Q</annotation></semantics></math></span></data> possible outputs, instead of the <data class="katex-src" value="Q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span></data> possible outputs in case of DFA. Each output corresponds to a unique element in the power set of <data class="katex-src" value="Q"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span></data>.</li>
<li><em>S</em> is the subset of acceptable states called the start states.</li>
<li><em>F</em> is the finite subset of <em>Q</em> that are acceptable as the final states.</li>
</ul>
<p>To define the acceptance, we use the following rules:</p>
<p><data class="katex-src" value="\hat{\Delta}\left(A,\epsilon\right) = A"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>ϵ</mi><mo fence="true">)</mo></mrow><mo>=</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\hat{\Delta}\left(A,\epsilon\right) = A</annotation></semantics></math></span></data></p>
<p><data class="katex-src" value="\hat{\Delta}\left(A, xa\right) = \bigcup_{q\in \hat{\Delta}\left(A,x\right)} \Delta\left(q,a\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mi>a</mi><mo fence="true">)</mo></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><mi>q</mi><mo>∈</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow></mrow></munder><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\Delta}\left(A, xa\right) = \bigcup_{q\in \hat{\Delta}\left(A,x\right)} \Delta\left(q,a\right)</annotation></semantics></math></span></data></p>
<p>Instead of the usual one state, we have the input to be a subset of the possible state for <data class="katex-src" value="\hat{\Delta}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\Delta}</annotation></semantics></math></span></data>.</p>
<p>Acceptance happens when <data class="katex-src" value="x \in \Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">x \in \Sigma^*</annotation></semantics></math></span></data> satisfies <data class="katex-src" value="\hat{\Delta} \left(S,x\right) \cap F \neq \phi"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>S</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo>∩</mo><mi>F</mi><mo mathvariant="normal">≠</mo><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\hat{\Delta} \left(S,x\right) \cap F \neq \phi</annotation></semantics></math></span></data></p>
<p>Proof for Deterministic and Non-deterministic Finite Automata being equivalent:</p>
<ul>
<li>First we prove that <data class="katex-src" value="\hat{\Delta}\left(A, xy\right) = \hat{\Delta}\left(\hat{\Delta}\left(A, x\right), y\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mi>y</mi><mo fence="true">)</mo></mrow><mo>=</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>y</mi><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\hat{\Delta}\left(A, xy\right) = \hat{\Delta}\left(\hat{\Delta}\left(A, x\right), y\right)</annotation></semantics></math></span></data></li>
</ul>
<p>Induction on |y|:</p>
<p>For |y| = 0, it is trivially true from the above equations.</p>
<p>Assume for |y| ≤ n,</p>
<p><data class="katex-src" value="\begin{align*}&#10;\hat{\Delta}\left(A, xya\right) &= \bigcup_{q\in \hat{\Delta}\left(A,xy\right)} \Delta\left(q,a\right) \\&#10;& = \bigcup_{q\in \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),y\right)} \Delta\left(q,a\right) \\&#10;& = \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),ya\right)&#10;\end{align*}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mi>y</mi><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><mi>q</mi><mo>∈</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mi>y</mi><mo fence="true">)</mo></mrow></mrow></munder><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mrow><mi>q</mi><mo>∈</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>y</mi><mo fence="true">)</mo></mrow></mrow></munder><mi mathvariant="normal">Δ</mi><mrow><mo fence="true">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mi>A</mi><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>y</mi><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*} \hat{\Delta}\left(A, xya\right) &amp;= \bigcup_{q\in \hat{\Delta}\left(A,xy\right)} \Delta\left(q,a\right) \ &amp; = \bigcup_{q\in \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),y\right)} \Delta\left(q,a\right) \ &amp; = \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),ya\right) \end{align*}</annotation></semantics></math></span></data></p>
<ul>
<li>Second, the function <data class="katex-src" value="\hat{\Delta}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover></mrow><annotation encoding="application/x-tex">\hat{\Delta}</annotation></semantics></math></span></data> commutes with the set union, i.e., <data class="katex-src" value="\hat{\Delta}(\bigcup_i A_i,x) = \bigcup_i \hat{\Delta}(A_i, x)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msub><mo>⋃</mo><mi>i</mi></msub><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>⋃</mo><mi>i</mi></msub><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mo stretchy="false">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\hat{\Delta}(\bigcup_i A_i,x) = \bigcup_i \hat{\Delta}(A_i, x)</annotation></semantics></math></span></data></li>
</ul>
<p>Induction on |x|:</p>
<p>For |x| = 0, it is trivially true.</p>
<p>Assume for |x| ≤ n.</p>
<p><data class="katex-src" value="\begin{align*}&#10;\hat{\Delta}\left(\bigcup_i A_i, xa\right) & = \hat{\Delta}\left(\hat{\Delta}\left(\bigcup_i A_i,x\right),a\right) \\ & = \hat{\Delta}\left(\bigcup_i\hat{\Delta}\left(A_i, x\right),a\right) \\ & = \bigcup_i \hat{\Delta}\left(\hat{\Delta}\left(A_i , x\right), a\right) \\ & = \bigcup_i\hat{\Delta}\left(A_i, xa\right)&#10;\end{align*}"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.25em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><munder><mo>⋃</mo><mi>i</mi></munder><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><munder><mo>⋃</mo><mi>i</mi></munder><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><munder><mo>⋃</mo><mi>i</mi></munder><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mi>i</mi></munder><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mo fence="true">)</mo></mrow><mo separator="true">,</mo><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><munder><mo>⋃</mo><mi>i</mi></munder><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mrow><mo fence="true">(</mo><msub><mi>A</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>x</mi><mi>a</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align*} \hat{\Delta}\left(\bigcup_i A_i, xa\right) &amp; = \hat{\Delta}\left(\hat{\Delta}\left(\bigcup_i A_i,x\right),a\right) \ &amp; = \hat{\Delta}\left(\bigcup_i\hat{\Delta}\left(A_i, x\right),a\right) \ &amp; = \bigcup_i \hat{\Delta}\left(\hat{\Delta}\left(A_i , x\right), a\right) \ &amp; = \bigcup_i\hat{\Delta}\left(A_i, xa\right) \end{align*}</annotation></semantics></math></span></data></p>
<p>Now the following two automata can be shown to accept the same set.</p>
<p><data class="katex-src" value="\left(Q, \Sigma, \Delta, S, F\right) = \left(2^Q, \Sigma, \hat{\Delta}, S, \{ A | A \subseteq Q, A \cap F ≠ \phi\} \right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">(</mo><mi>Q</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi mathvariant="normal">Δ</mi><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mi>F</mi><mo fence="true">)</mo></mrow><mo>=</mo><mrow><mo fence="true">(</mo><msup><mn>2</mn><mi>Q</mi></msup><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mover accent="true"><mi mathvariant="normal">Δ</mi><mo>^</mo></mover><mo separator="true">,</mo><mi>S</mi><mo separator="true">,</mo><mo stretchy="false">{</mo><mi>A</mi><mi mathvariant="normal">∣</mi><mi>A</mi><mo>⊆</mo><mi>Q</mi><mo separator="true">,</mo><mi>A</mi><mo>∩</mo><mi>F</mi><mo mathvariant="normal">≠</mo><mi>ϕ</mi><mo stretchy="false">}</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\left(Q, \Sigma, \Delta, S, F\right) = \left(2^Q, \Sigma, \hat{\Delta}, S, { A | A \subseteq Q, A \cap F ≠ \phi} \right)</annotation></semantics></math></span></data></p>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<ul>
<li><data class="katex-src" value="a"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></data> for each <data class="katex-src" value="a \in \Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">a \in \Sigma</annotation></semantics></math></span></data>, matched by <data class="katex-src" value="a"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span></data> only.</li>
<li><data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data>, matched by the empty string.</li>
<li><data class="katex-src" value="\phi"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϕ</mi></mrow><annotation encoding="application/x-tex">\phi</annotation></semantics></math></span></data>, matched by nothing.</li>
<li>#, matched by any symbol in <data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="@"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">@</mi></mrow><annotation encoding="application/x-tex">@</annotation></semantics></math></span></data>, matched by anything in <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data>.</li>
</ul>
<h3 id="combining-patterns"><a class="header" href="#combining-patterns">Combining patterns</a></h3>
<ul>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha + \beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>+</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha + \beta</annotation></semantics></math></span></data> if <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches either of those.</li>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha\cap\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>∩</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha\cap\beta</annotation></semantics></math></span></data> if <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches both of them.</li>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha\beta</annotation></semantics></math></span></data> if <data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span></data> followed by <data class="katex-src" value="\beta"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="~\alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext> </mtext><mi>α</mi></mrow><annotation encoding="application/x-tex">~\alpha</annotation></semantics></math></span></data> if it doesn’t match <data class="katex-src" value="\alpha"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span></data>.</li>
<li><data class="katex-src" value="x"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span></data> matches <data class="katex-src" value="\alpha^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\alpha^*</annotation></semantics></math></span></data> and <data class="katex-src" value="\alpha^+"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">\alpha^+</annotation></semantics></math></span></data> the same way as regex.</li>
</ul>
<h2 id="class"><a class="header" href="#class">Class</a></h2>
<p><strong>Theorem:</strong> Set of all C Programs is countable.</p>
<p>Proof: <br></p>
<p>Represent the ascii source code in binary. Then it will be a subset of <data class="katex-src" value="\{0,1\}^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">}</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">{0,1}^*</annotation></semantics></math></span></data> and that is bijective with the natural numbers (<data class="katex-src" value="n(b) + 2^{|b|} -1"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><msup><mn>2</mn><mrow><mi mathvariant="normal">∣</mi><mi>b</mi><mi mathvariant="normal">∣</mi></mrow></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n(b) + 2^{|b|} -1</annotation></semantics></math></span></data>). It is also obviously infinite.</p>
<blockquote>
<p>Hilbert’s Entscheidungs Problem: Given a mathematical statement, is it derivable from the axioms.</p>
</blockquote>
<p><strong>Defn:</strong> A language <data class="katex-src" value="L"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span></data> over an alphabet <data class="katex-src" value="\Sigma"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span></data> is a subset of <data class="katex-src" value="\Sigma^*"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span></data>.</p>
<p><strong>Theorem:</strong> The cardinality of all the languages over some alphabet is uncountably infinite, i.e., <data class="katex-src" value="\left|\mathcal{P}\left(L\right)\right| > \left|\mathbb{N}\right|"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo fence="true">∣</mo><mi mathvariant="script">P</mi><mrow><mo fence="true">(</mo><mi>L</mi><mo fence="true">)</mo></mrow><mo fence="true">∣</mo></mrow><mo>&gt;</mo><mrow><mo fence="true">∣</mo><mi mathvariant="double-struck">N</mi><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">\left|\mathcal{P}\left(L\right)\right| &gt; \left|\mathbb{N}\right|</annotation></semantics></math></span></data>.</p>
<p>Proof:</p>
<p>Cantor’s argument:</p>
<p>Set of all languages = <data class="katex-src" value="\mathcal{P}\left(\{0,1\}^*\right)"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">P</mi><mrow><mo fence="true">(</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><msup><mo stretchy="false">}</mo><mo>∗</mo></msup><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\mathcal{P}\left({0,1}^*\right)</annotation></semantics></math></span></data></p>
<div class="table-wrapper"><table><thead><tr><th>input</th><th><data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data></th><th>0</th><th>1</th><th>00</th></tr></thead><tbody>
<tr><td>f(<data class="katex-src" value="\epsilon"><span class="katex"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span></data>)</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>
<tr><td>f(0)</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>f(1)</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>f(01)</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>
</tbody></table>
</div>
<p>The entries in the table tell whether that particular element is present in the subset that is obtained from the result or not.</p>
<p>Take the diagonal and bit flip all bits. It will differ from all the strings in the table by atleast one bit.</p>
<p>Go to <a href="./cs2200.html#cs2200">top</a> till <a href="./cs2200.html#deterministic-finite-automata">Deterministic Finite Automata</a> along with a few examples of languages based on the problem.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../notes/cp_qs_reading.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../notes/cs2600.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../notes/cp_qs_reading.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../notes/cs2600.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
