# cs2200

Types of grammar:

1. Right linear
2. Context free
3. unrestricted

Types of machine models:

1. finite memory: finite automata, regex
2. finite memory with stack: pushdown automata
3. unrestricted: turing machines, post systems, λ calculus etc.

There is a one to one correspondence for the numberings above.

> Gödel's incompleteness theorem: No matter how strong a deductive system is, there are always statements that are true but unprovable.

## Strings and Sets

> *Decision problem* is a function that has a one bit output: true or false, 1 or 0.

To completely specify a decision problem, specify a set of possible inputs and the subset for which the output is true.

Encoding the input of a decision problem as a fixed finite length string is possible over some fixed finite alphabet.

> A **finite alphabet** is any finite set. A finite length string is a sequence of the elements.

Set ops for two sets:

- Union
- Intersection
- Complement over set of all strings: Basically, it depends on the **set of all strings** that is chosen and hence this is often written as $\Sigma^* - A$ to emphasize this. 
- Concatenation of two sets: $AB = \{xy | x \in A; y \in B\}$. 

Set ops on one set:

- *asterate* A* of a set. $A^* = \bigcup_{n\geq 0}A^n$
- A<sup>+</sup> of a set. $A^+ = \bigcup_{n \geq 1}A^n$.

## States and transitions

A **state** of a system gives all the relevant information of a system, like a *snapshot*. **Transitions** are changes of states.

If both are finite, then the system is called a *finite state transition* system. We model them using *finite automata*. 

### Deterministic Finite Automata

Formally,

$$M = \left(Q,\Sigma,\delta,s,F\right)$$

- *Q* is the finite set of states.
- $\Sigma$ is the finite set of the input *alphabet*.
- $\delta$ is the transition function that takes the current state and the input *character* as the inputs and gives the next state as the output.
- *s* is the start state.
- *F* is the finite subset of *Q* that are acceptable as the final states.

To extend the character input to a *string*, we define $\hat{\delta}$ inductively as follows:

- $\hat{\delta}\left(q, xa\right) = \delta\left(\hat{\delta}\left(q, x\right), a\right)$
- $\hat{\delta}\left(q, \epsilon\right) = q$

Where $x$ is a *string*, $a$ is a character, and $\epsilon$ is the empty input.

These can also be translated to the finite state machines [discussed here](./csd.html#finite-state-machines).

A string $x$ is accepted by an automation $M$ if 

$$\hat{\delta}\left(s,x\right) \in F$$

A *set* or a *language* accepted by $M$ is the set of all strings accepted by some automata $M$, also called $L(M)$. Any subset of $\Sigma^*$ is said to be regular if it is accepted by some automaton $M$.

### Non-deterministic Finite Automata

A finite automata where the next state is not necessarily determined by the current state and the input symbol. It is effectively in a state of *guesssing*.

To show that an automata accepts a set $B$, we argue that there exists a lucky sequence of guesses that lead from the start state to an accept state when the end of $x\in B$ is reached, but for any string outside of the set, it is impossible.


Formally,

$$M = \left(Q,\Sigma,\Delta,S,F\right)$$

- *Q* is the finite set of states.
- $\Sigma$ is the finite set of the input *alphabet*.
- $\Delta$ is the transition function that takes the current state and the input *character* as the inputs and gives the next state as the output. In this case, there are $2^Q$ possible outputs, instead of the $Q$ possible outputs in case of DFA. Each output corresponds to a unique element in the power set of $Q$.
- *S* is the subset of acceptable states called the start states.
- *F* is the finite subset of *Q* that are acceptable as the final states.


To define the acceptance, we use the following rules:

$$\hat{\Delta}\left(A,\epsilon\right) = A$$
$$\hat{\Delta}\left(A, xa\right) = \bigcup_{q\in \hat{\Delta}\left(A,x\right)} \Delta\left(q,a\right)$$

Instead of the usual one state, we have the input to be a subset of the possible state for $\hat{\Delta}$.

Acceptance happens when $x \in \Sigma^*$ satisfies $\hat{\Delta} \left(S,x\right) \cap F \neq \phi$

Proof for Deterministic and Non-deterministic Finite Automata being equivalent:

- First we prove that $\hat{\Delta}\left(A, xy\right) = \hat{\Delta}\left(\hat{\Delta}\left(A, x\right), y\right)$

Induction on |y|:

For |y| = 0, it is trivially true from the above equations.

Assume for |y| ≤ n,

$$\begin{align*}
\hat{\Delta}\left(A, xya\right) &= \bigcup_{q\in \hat{\Delta}\left(A,xy\right)} \Delta\left(q,a\right) \\
& = \bigcup_{q\in \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),y\right)} \Delta\left(q,a\right) \\
& = \hat{\Delta}\left(\hat{\Delta}\left(A,x\right),ya\right)
\end{align*}$$

- Second, the function $\hat{\Delta}$ commutes with the set union, i.e., $\hat{\Delta}(\bigcup_i A_i,x) = \bigcup_i \hat{\Delta}(A_i, x)$

Induction on |x|:

For |x| = 0, it is trivially true.

Assume for |x| ≤ n.


$$\begin{align*}
\hat{\Delta}\left(\bigcup_i A_i, xa\right) & = \hat{\Delta}\left(\hat{\Delta}\left(\bigcup_i A_i,x\right),a\right) \\ & = \hat{\Delta}\left(\bigcup_i\hat{\Delta}\left(A_i, x\right),a\right) \\ & = \bigcup_i \hat{\Delta}\left(\hat{\Delta}\left(A_i , x\right), a\right) \\ & = \bigcup_i\hat{\Delta}\left(A_i, xa\right)
\end{align*}$$


Now the following two automata can be shown to accept the same set.

$$\left(Q, \Sigma, \Delta, S, F\right) = \left(2^Q, \Sigma, \hat{\Delta}, S, \{ A | A \subseteq Q, A \cap F ≠ \phi\} \right)$$
