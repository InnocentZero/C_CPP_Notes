# cs2600

## Instruction Set

Different Instructions: x86, ARM, RISC V, MIPS.

- Programs written for one processor cannot execute on another.
- Early trend: more instructions, complex instructions.
- RISC -- Reduced Instruction Set Computing
  - Instructions are small and simple
  - Software does not complicate operations.

### How compilation happens

First the assembler converts the assembly to an object file. Here, the addresses
start with 0 and are relocatable. Later on the linker links multiple such object
files together and resolves function addresses, starting location, etc. using
something called as a **Linker Descriptor Script**.

## RISC V

Open source. Has 32 int and 32 FP registers. Also has XLEN variable, which is
either 32 or 64 for 32-bit and 64-bit processors respectively.

| Register | ABI Name |                   Description                    | Saver  |
| :------: | :------: | :----------------------------------------------: | :----: |
|    x0    |   zero   |                   Zero always                    |        |
|    x1    |    ra    |                  Return address                  | caller |
|    x2    |    sp    |                  Stack Pointer                   | callee |
|    x3    |    gp    |                  Global Pointer                  |        |
|    x4    |    tp    |                  Thread Pointer                  |        |
|  x5-x7   |  t0-t2   |                      Temps                       | caller |
|    x8    |  s0 /fp  | saved / frame pointer (base pointer effectively) | callee |
|    x9    |    s1    |                  saved register                  | callee |
| x10-x11  |  a0-a1   |              Fn args/ return values              | callee |
| x12-x18  |  a2-a7   |                     Fn args                      | caller |
| x18-x27  |  s2-s11  |                 Saved registers                  | callee |
| x27-x31  |  t3-t6   |                   Temporaries                    | caller |

> Maximum memory depends on the size of the address bus from the load store unit
> to the memory.

The caller saved registers have to be explicitly saved by the caller function
in a stack frame before calling the other function. On the other hand, callee
saved functions are guaranteed to stay the same across function calls and there
is no need for functions to save them.

### Instructions

The ones listed below are called *R-type* or *register-type* instructions.

- `add rd, rs1, rs2`: add the contents of rs1 and rs2 and store it in rd.
  Signed addition. Also has the unsigned version. Similarly, sub, and, or, xor
  also exist.

- `mul/mulh rd, rs1, rs2`: multiplies and stores the lower/upper 32 bits in rd.

- `div/rem rd, rs1, rs2`: stores the quotient/remainder.

- `sll rd, rs1, rs2`: Left shift the number in rs1 by the value in rs2 and
  store in rd.

- `srl rd, rs1, rs2`: Right shift the number in rs1 by the value in rs2 and
  store in rd. Zero extends.

- `sra rd, rs1, rs2`: Right shift the number in rs1 by the value in rs2 and
  store in rd. Sign extends.

All of these also have an immediate version where the last argument is a
hardcoded literal.

These are called *I-type* or *immediate-type* instructions.

- `l(b/h/w) rd, imm(rs1)`: loads a byte/half-word/word to rd(dest. register)
  from \*(rs1 + imm)

- `l(b/h/w)u rd, imm(rs1)`: loads a byte/half-word/word to rd(dest. register)
  from \*(rs1 + imm). This one zero-extends on the left.

These are also *I-type* instructions.

The below one instruction is *S-type* instruction (for obvious reasons).

- `s(b/h/w) rd, imm(rs1)`: stores a byte/half-word/word to \*(rs1 + imm)
  from the contents of rd.

The below instruction is called *B-type* or *branch-type* instruction.

- `blt/bltu r1, r2, label/offset`: if r1 \< r2 (signed or unsigned), jump to
  label or symbol. Can jump to atmost 4 KiB. (13 bits with the lsb always 0, the
  rest are used for determining values).

The above instructions have greater than, greater than equal to variants as
well. Also immediate variants of all.

#### Function calls

All of these can jump to at most 1 MiB as they take an immediate value of 20
bits apart from the lsb that's always 0.

The below type is called a *J-type* instruction.

- `jal rd, imm`: Jump to PC + imm, and store pc + 4 in register rd.

The below one is an ***I-type*** and **NOT** J-type.

- `jalr rd, rs1, imm`: Jump to rs1 + imm, storing PC + 4 in the register
  rd. Used for function pointers.

Both of the ones below are aliases.

- `j label`: alias to `jal zero, label`, discards the return address

- `ret rs1`: return to the address in rs1, if no argument is specified use
  ra (return addres register/x1). Alias to `jalr zero, rs1, 0`

For function calls we also need a stack-based execution. s2 register is the
stack pointer that points to the top of the stack. Frame pointer s0 saves the
base of the stack. These mark the stack frame in the stack.

> Always load and save values relative to the frame pointer.

Registers a0 to a7 are used to pass function arguments from one function to
another. These are 8 parameters. If we have more, then you need to use the
stack.

#### Control and status registers

- `csrrw rd, csr, rs`: atomic swap values

- `csrrs rd, csr, rs`: atomic read from rd and set a bit

- `csrrc rd, csr, rs`: atomic read from rd and reset a bit

Atomic means that interrupts won't stop the entire set of operations that is
going on.

### Executing instructions

If we are using an operating system:

- Proxy Kernel is handling syscalls, mapping memory, program counter
  according to memory map, etc.

If we are without an operating system:

- Manually write the `.text` section to the flash memory.
- Load the `.data` section to the RAM.
- Set/reset the program counter to the required memory. It resets to a fixed
  value called as **reset vector**.
- Address out of range is your skill issue.
- Instruction fetched by the **Instruction Pointer**. 32 bits in width.
- Then it is sent to control ROM. This does not have microcodes and are instead
  hardcoded using combinational circuit.

#### Register Bank

Has all the registers and 2 muxs + 1 demux to select the register to use. There
is *dual porting* to read two source registers at once (hence two muxes).

#### Program Counter

This keeps track of the next instruction to be executed. Usually incremented by
4 unless branches. It resets to a fixed value called as **reset vector**.

Instructions and data are fetched every rising edge of the clock and that is
when the program counter is also incremented by 4.
The instruction fetched is later stored in the **instruction register**.

The instruction register sends it to the control unit which later sends signals
to whatever is responsible.

It also gets reset at interrupts to an interrupt vector and begins to consume
instructions from there.

#### ALU

Performs arithmetic (no shit). Has the **gen** module before it that generates
the immediate instruction from the opcode, regardless of whether it was an
*I-type* or not.

After this, there is a 2:1 mux that has a select line coming from the Control
Unit that decides whether or not the immediate values has to be selected or not,
the other option being 0.

## Multiprecision Arithmetic in RISCV

Multiprecision addition

```assembly
{{#include ./riscv/multiprec_add.s }}
```

Multiprecision subtraction

```assembly
{{#include ./riscv/multiprec_sub.s }}
```

Multiprecision multiplication

This is WRONG!!!!

```assembly
{{#include ./riscv/multiprec_mult.s}}
```

## Function call examples in RISCV

Recursive fibonacci

```assembly
{{#include ./riscv/recursive_fib.s}}
```

## Peripherals

They are also mapped to the memory. And properties can be changed using that
memory area.

The driver can be blocking or non-blocking. If blocking, it takes up a lot of
CPU power as it keeps polling the peripheral for data.
If it is non-blocking, then there are interrupts then they are detected at
hardware level within a clock cycle.

### Interrupts

If there is an interrupt, then the program jumps to the supplied **interrupt
service routine** and starts executing from there and returns to the OG
instruction once everything is done.

Hardware interrupts are done by a bus manager like the network controller (that
straight away receives a bunch of kilobytes) and use *DMA* (Direct Memory
Access) to straight away start using the memory.

There are software interrupts (for accessing devices like IO, sockets, etc.)
and hardware interrupts for, well, other stuff.

Apart from that there are exceptions as well that are raised by the CPU when
buttfuckery like division by 0 happens.

All the peripherals are connected to the **PLIC** (*Platform Level Interrupt
Controller*). There is also **CLINT** (*Control Local Interrupt Timer*) that
gives each core timer interrupts
that can be used a scheduler.

Interrupts have modes that define previlege level:

- Machine level: M mode, most privileged
- Supervisor level: S mode, OS privilege
- User level: U mode, all binaries run here

> In Intel machines these are called rings.

### Interrupt Handling

#### What caused the interrupt?

`mcause` has the first bit reserved for the interrupt type (interrupt or error)
and the rest 31 bits are used for indicating the subtype of the interrupt.

If the first bit is 1 then it was an interrupt else it was an exception.

To find out what peripheral caused the interrupt, the CPU uses the value given
by *PLIC*.

Filled automatically by the hardware when an interrupt happens.

#### Where is the interrupt vector address?

`mtvec` stores the address of the interrupt vector.

If the *mode* value is set to 1, it is **vectored**. The `pc` is set to
**BASE + 4 * cause**.

If *mode* is set to 0, it is a **direct** interrupt and all exceptions set
`pc` to **BASE**.

2 and 3 are reserved for future use.

> NOT hardcoded!!

#### Where to return to?

`mepc` holds the value of `pc` when the interrupt occured.

`mret` instruction loads the `mepc` to the `pc`.

#### What was the previous status level?

`mstatus` register has 4 bits that are mostly relevant to us.

`MPP[1:0]` stores the previous execution mode.

`MPIE` holds the interrupt enable status in the previous mode. This is used to
determine if the previous mode had interrupts enabled for the lower privileges.

### Nested interrupts

To enable a nested interrupt, copy the data from `mepc`, `mcause` and `mstatus`.

`mie` register enables interrupts in machine mode if set. It is set to zero at
the start of the interrupt to make sure no other interrupts disturb the copying
of the data during a nested interrupt.

- 11th bit for external/DMA interrupt.
- 7th bit for timer interrupt.
- 3rd bit for Software interrupt.

### Pending Interrupts

`mip` register holds the important bits for any interrupt that wasn't executed
in between an instruction.

Bit scheme is the same as above.

## Virtual Memory Addressing

We introduce a **paging unit** between physical memory and the CPU, which is
unique for every process.

RAM is split into multiple page frames (usually 4 KiB). The virtual memory is
also split into multiple chunks of 4KiB size. These two chunks are then mapped
in some fashion which is stored in the **process page table**.

While scheduling, the program has an active page table that is maintained during
the program's runtime. In some cases, pages from multiple programs are loaded
simultaneously to the memory.

### Demand Paging

Virtual memory takes advantage of the fact that not all blocks need to be loaded
at once for the program to be executed. Hence, the paging table also has a value
called present bit that tells you if the page is present in the CPU or not.

If a page is not loaded when it was supposed to be, the program raises an
interrupt called **page fault exception**. There is a page fault exception
handler that takes care of loading the page and fill the page table. It may
remove a page frame of some other process if necessary.

There is another bit that keeps track of whether or not a page needs to be
written back to *swap* because of data updation. If the dirty bit is set to *1*,
we write stuff back to the swap. Else we don't to save memory operations.

There are also (usually 2) protection bits for each page to indicate the
permissions of each page. These are used for maintaining stuff like the code
being readable, stack being non-executable, etc.

Usually there are 2 level paging, where one table has the address of another
sub-table and there is an offset that are used together to obtain the memory.

### Shared memory

If two programs have the same page frame, then they share the same memory
physically that lets them have a common shared memory (eg. glibc sharing,
VDSO in linux).
You can also duplicate a page within a program by pointing two blocks to the
same frame.

### 2 level paging

The virtual address has the first 10 bits as offset from the
**page table base register**. This gives you the exact address of the page
table from the page directory. The next 10 bits store the offset from the base
of the page table. From this value the first 20 bits of the physical address
are obtained. The last 12 bits for both virtual and physical address are the
same. This scheme supports page sizes of 4KB and 2 MB.

For the *satp* register (the page table base register), the MSB will indicate
that translation is on or not. The next 9 bits are just meant for address space
separation for different processes. The next 22 bits hold the address of the
first level directory of the page translation.

The page table format is as follows:

| PPN\[1\]                 | PPN\[0\]                 | RSW                | D                         | A                            | G                                                                                                               | U            | X                | W            | R           | V            |
| ------------------------ | ------------------------ | ------------------ | ------------------------- | ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------ | ---------------- | ------------ | ----------- | ------------ |
| 12: physical page number | 10: physical page number | 2: reserved for OS | 1: Dirty (0 for non-leaf) | 1: Accessed (0 for non-leaf) | 1: set to check whether the mapping is valid or not for all virtual address spaces, usually only used by the OS | 1: User mode | 1: execution bit | 1: write bit | 1: read bit | 1: valid bit |

The PPN\[1\] + PPN\[0\] of the first level are used to get the address of the
second level table. Once we get that, we use the PPN\[1\] + PPN\[0\] to get the
first 22 bits of the **34 bit** physical page address. The last 12 bits are the
offset bits from the OG virtual page address. 34 bits somehow work??

### 3 level paging

This is done for 64 bit architecture. This comes in two variants:

- 39 bit addressing
- 48 bit addressing

#### 39 bit

This scheme can support page tables of sizes 2KB, 2MB, 1GB. The most significant
25 bits are unused. There are a total of $2^{27}$ page table entries. Once again
, last 12 bits are the same.

The page table entry is as follows:

| *Reserved*                  | PPN\[2\]                 | PPN\[1\]                | PPN\[0\]                | RSW                | D                         | A                            | G                                                                                                               | U            | X                | W            | R           | V            |
| --------------------------- | ------------------------ | ----------------------- | ----------------------- | ------------------ | ------------------------- | ---------------------------- | --------------------------------------------------------------------------------------------------------------- | ------------ | ---------------- | ------------ | ----------- | ------------ |
| 10: reserved for future use | 26: physical page number | 9: physical page number | 9: physical page number | 2: reserved for OS | 1: Dirty (0 for non-leaf) | 1: Accessed (0 for non-leaf) | 1: set to check whether the mapping is valid or not for all virtual address spaces, usually only used by the OS | 1: User mode | 1: execution bit | 1: write bit | 1: read bit | 1: valid bit |

Once again, all of PPN\[2\] + PPN\[1\] + PPN\[0\] bits will be used to find the
page directory beginning in the subsequent levels.

## Von Neumann Architecture

Fetches the memory into various kinds of buffers to speed up memory fetch by
CPU.

### Caches

Each core has separate L1 cache for instructions and data. L2 cache is common
for both and mostly per-core (can also be shared across multiple cores). L3
cache is shared across all the cores.

### Registers

Apart from this there are also registers next to the ALU to speed up computation
. More can be slower or faster depending on the number. More means lesser loads
and stores. More also means longer routes (more time for pulse to travel) and
clock cycle logic to choose the register become slower.

### RAM memory

- Has capacitors.
- Capacitors discharge over time hence needs to be continuously powered and
  recharged.
- Take time to charge and discharge, which creates bottlenecks for CPU.

#### DRAM

Flow of types through time:

- SDRAM: Synchronous DRAM
- RDRAM: Rambus (company)
- DDR DRAM: Double data rate - over here both rising and falling edges will
  have actions.

DIMM chips: Dual inline memory modules

There are two ranks, with 8 chips for each. One rank is on one side. Each bus
activates all the 8 bits at once.
This is more efficient as one DRAM chip can be held using 8 pins only. This
reduces size and number of pins (they are costly).

However, this activates all the 8 DRAM chips at once when we don't need to, so
it is power inefficient.

For each DRAM cell, there are **banks**, each of which has 8 arrays. Each array
has 64 bits, however the data is stored so that all the 8 arrays store a bit
each for any byte.

Each array has a *RAS* (row access strobe) and a *CAS* (column access strobe).
There are 8 rows and 8 columns. Each row has 8 bits, **but not from the
same byte**. Those are parallel.

Each RAS has selects a row and each CAS selects a column to fetch a bit. All the
8 bits from each of the array combine to form a byte. Therefore a bank stores
64 bytes but in parallel.

> Row hammer attack: When you activate rows that have one row in between such
> that the row in between changes values due to EM fields.
> Saltanat's work
