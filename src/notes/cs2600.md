# cs2600

## Von Neumann Architecture

Fetches the memory into various kinds of buffers to speed up memory fetch by CPU.

### Caches

Each core has separate L1 cache for instructions and data. L2 cache is common for both and mostly per-core (can also be shared across multiple cores). L3 cache is shared across all the cores.

### Registers

Apart from this there are also registers next to the ALU to speed up computation. More can be slower or faster depending on the number. More means lesser loads and stores. More also means longer routes (more time for pulse to travel) and clock cycle logic to choose the register become slower.

### RAM memory

- Has capacitors.
- Capacitors discharge over time hence needs to be continuously powered and recharged.
- Take time to charge and discharge, which creates bottlenecks for CPU.

## Instruction Set

Different Instructions: x86, ARM, RISC V, MIPS.

- Programs written for one processor cannot execute on another.
- Early trend: more instructions, complex instructions.
- RISC -- Reduced Instruction Set Computing
  - Instructions are small and simple
  - Software does not complicate operations.

## RISC V

Open source. Has 32 int and 32 FP registers. Also has XLEN variable, which is either 32 or 64 for 32-bit and 64-bit processors respectively.

| Register | ABI Name |                   Description                    |
| :------: | :------: | :----------------------------------------------: |
|    x0    |   zero   |                   Zero always                    |
|    x1    |    ra    |                  Return address                  |
|    x2    |    sp    |                  Stack Pointer                   |
|    x3    |    gp    |                  Global Pointer                  |
|    x4    |    tp    |                  Thread Pointer                  |
|  x5-x7   |  t0-t2   |                      Temps                       |
|    x8    |  s0 /fp  | saved / frame pointer (base pointer effectively) |
|    x9    |    s1    |                  saved register                  |
| x10-x11  |  a0-a1   |              Fn args/ return values              |
| x12-x18  |  a2-a7   |                     Fn args                      |
| x18-x27  |  s2-s11  |                 Saved registers                  |
| x27-x31  |  t3-t6   |                   Temporaries                    |

> Maximum memory depends on the size of the address bus from the load store unit to the memory.

### Instructions

- `add rd, rs1, rs2`: add the contents of rs1 and rs2 and store it in rd. Signed addition. Also has the unsigned version. Similarly, sub, and, or, xor also exist.

- `mul/mulh rd, rs1, rs2`: multiplies and stores the lower/upper 32 bits in rd.

- `div/rem rd, rs1, rs2`: stores the quotient/remainder.

- `sll rd, rs1, rs2`: Left shift the number in rs1 by the value in rs2 and store in rd.

- `srl rd, rs1, rs2`: Right shift the number in rs1 by the value in rs2 and store in rd. Zero extends.

- `sra rd, rs1, rs2`: Right shift the number in rs1 by the value in rs2 and store in rd. Sign extends.

All of these also have an immediate version where the last argument is a hardcoded literal.

- `l(b/h/w) rd, imm(rs1)`: loads a byte/half-word/word to rd(dest. register) from \*(rs1 + imm)

- `l(b/h/w)u rd, imm(rs1)`: loads a byte/half-word/word to rd(dest. register) from \*(rs1 + imm). This one zero-extends on the left.

- `s(b/h/w) rd, imm(rs1)`: stores a byte/half-word/word to \*(rs1 + imm) from the contents of rd.

- `j offset/label`: jump to the given label/offset

- `blt/bltu r1, r2, label/offset`: if r1 \< r2 (signed or unsigned), jump to label or symbol.

The above instructions have greater than, greater than equal to variants as well. Also immediate variants of all.

#### Function calls

- `jal rd, imm`: Jump to PC + imm, and store pc + 4 in register rd.

- `jalr rd, rs1, imm`: Jump to rs1 + imm, storing PC + 4 in the register rd. Used for function pointers.

- `j label`: alias to `jal zero, label`, discards the return address

- `ret rs1`: return to the address in rs1, if no argument is specified use ra (return addres register/x1). Alias to `jal rs1, 0`

For function calls we also need a stack-based execution. s2 register is the stack pointer that points to the top of the stack. Frame pointer s0 saves the base of the stack.
These mark the stack frame in the stack.

Registers a0 to a7 are used to pass function arguments from one function to another. These are 8 parameters. If we have more, then you need to use the stack.

### Executing instructions

If we are using an operating system:

- Proxy Kernel is handling syscalls, mapping memory, program counter according to memory map, etc.

If we are without an operating system:

- Manually write the `.text` section to the flash memory.
- Load the `.data` section to the RAM.
- Set/reset the program counter to the required memory. It resets to a fixed value called as **reset vector**.
- Address out of range is your skill issue.
- Instruction fetched by the **Instruction Pointer**. 32 bits in width.
- Then it is sent to control ROM. This does not have microcodes and are instead hardcoded using combinational circuit.

#### Register Bank

Has all the registers and 2 muxs + 1 demux to select the register to use.

#### Program Counter

This keeps track of the next instruction to be executed. Usually incremented by 4 unless branches. It resets to a fixed value called as **reset vector**.

## Multiprecision Arithmetic in RISCV

Multiprecision addition

```assembly
{{#include ./riscv/multiprec_add.s }}
```

Multiprecision subtraction

```assembly
{{#include ./riscv/multiprec_sub.s }}
```

Multiprecision multiplication

This is WRONG!!!!

```assembly
{{#include ./riscv/multiprec_mult.s}}
```

## Function call examples in RISCV

Recursive fibonacci

```assembly
{{#include ./riscv/recursive_fib.s}}
```
